<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Ajoo's Blog - SDR</title><link href="http://ajoo.blog/" rel="alternate"></link><link href="http://ajoo.blog/feeds/sdr.atom.xml" rel="self"></link><id>http://ajoo.blog/</id><updated>2017-02-07T13:00:00+00:00</updated><entry><title>Intro to RTL-SDR, Part II -Â Software</title><link href="http://ajoo.blog/intro-to-rtl-sdr-part-ii-software.html" rel="alternate"></link><published>2017-02-07T13:00:00+00:00</published><updated>2017-02-07T13:00:00+00:00</updated><author><name>Ajoo</name></author><id>tag:ajoo.blog,2017-02-07:/intro-to-rtl-sdr-part-ii-software.html</id><summary type="html">&lt;p&gt;A summary of what I&amp;#8217;ve learned about &lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt; so far. From the working principles of the &lt;span class="caps"&gt;USB&lt;/span&gt; dongles to the software I intend to use to capture and process the data for future&amp;nbsp;projects.&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;div class="figure"&gt;
	&lt;img src="https://ajoo.blog/external_images/SDRBlogImage_1_Rotated.jpg" width="500" alt="RTL-SDR blog USB dongle"&gt;
	&lt;p class="caption"&gt;&lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt; blog &lt;span class="caps"&gt;USB&lt;/span&gt; dongle. &lt;a href=http://www.rtl-sdr.com/buy-rtl-sdr-dvb-t-dongles/&gt;Image&amp;nbsp;source&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;In this second and final part of my introduction to &lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt; I&amp;#8217;ll go over the most popular software that is available for use with &lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt; dongles. I&amp;#8217;ll try to provide a big picture but I&amp;#8217;ll be focusing more on what I intend to use in future &lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt;&amp;nbsp;projects.&lt;/p&gt;
&lt;p&gt;As a software defined radio Hello World of sorts I&amp;#8217;ll go over how to demodulate &lt;span class="caps"&gt;FM&lt;/span&gt; signals using a variety of tools. First using specialized software that does the demodulation for us (&lt;span class="caps"&gt;SDR&lt;/span&gt;# and rtl_fm) and then doing the demodulation directly from captured samples of the complex-baseband representation (&lt;span class="caps"&gt;IQ&lt;/span&gt;) using the python scientific computing&amp;nbsp;ecosystem. &lt;/p&gt;
&lt;p&gt;This post builds on the concepts presented in the &lt;a href="http://ajoo.blog/intro-to-rtl-sdr-part-i-principles-and-hardware.html"&gt;first part of this introduction&lt;/a&gt; helping frame them in the context of a real world&amp;nbsp;application.&lt;/p&gt;
&lt;h1&gt;&lt;span class="caps"&gt;SDR&lt;/span&gt;#&lt;/h1&gt;
&lt;p&gt;The &lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt; blog has a great &lt;a href="http://www.rtl-sdr.com/qsg"&gt;quickstart guide&lt;/a&gt; to get you started with your &lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt; &lt;span class="caps"&gt;USB&lt;/span&gt; dongle. If you&amp;#8217;re on Windows and follow the &lt;span class="caps"&gt;SDR&lt;/span&gt;# Setup Guide section you should be able to get your generic WinUSB drivers installed and your dongle working with &lt;span class="caps"&gt;SDR&lt;/span&gt;#. This program is a bit of a Jack of all trades when it comes to &lt;span class="caps"&gt;SDR&lt;/span&gt;. With a nice &lt;span class="caps"&gt;GUI&lt;/span&gt; interface it is able to demodulate many different kinds of signals providing you a nice visualization of the power spectral density (&lt;span class="caps"&gt;PSD&lt;/span&gt;) estimate and spectrogram (also known as waterfall) of the output of your &lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt;. Below is a screenshot of the program running when tuned for a section of the comercial &lt;span class="caps"&gt;FM&lt;/span&gt;&amp;nbsp;band:&lt;/p&gt;
&lt;p&gt;&lt;img alt="SDR# screenshot" src="https://ajoo.blog/images/SDR_sharp_screenshot.jpg"&gt;&lt;/p&gt;
&lt;p&gt;We won&amp;#8217;t play around much with this program so I won&amp;#8217;t elaborate more, but it&amp;#8217;s always nice to have around. Make sure to tune to an &lt;span class="caps"&gt;FM&lt;/span&gt; radio station you like that has a strong enough signal and write down its frequency. I will be using 97.4 MHz throughout this post, the frequency for Radio Comercial here in Lisbon, which has a particularly strong signal where I&amp;#8217;m&amp;nbsp;living.&lt;/p&gt;
&lt;h1&gt;librtlsdr and the rtl-sdr&amp;nbsp;codebase&lt;/h1&gt;
&lt;p&gt;Most software that interfaces with the &lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt; makes use of this library. If you followed the quickstart guide linked above and downloaded &lt;span class="caps"&gt;SDR&lt;/span&gt;#, one of the things it has you do is run a batch file that downloads a pre-build package of this codebase and copies the 32 bit version of rtlsdr.dll to the sdrsharp folder. Sadly it throws the rest of it away so you&amp;#8217;ll have to go ahead to the &lt;a href="http://sdr.osmocom.org/trac/wiki/rtl-sdr"&gt;Osmocom rtl-sdr website&lt;/a&gt; and download it again if you need the 64 bit version and the command line utilities that come packaged with it. You can either grab the &lt;a href="http://sdr.osmocom.org/trac/attachment/wiki/rtl-sdr/RelWithDebInfo.zip"&gt;pre-built windows version&lt;/a&gt; or &lt;a href="http://sdr.osmocom.org/trac/wiki/rtl-sdr#Buildingthesoftware"&gt;build it from source&lt;/a&gt; if you&amp;#8217;re on Linux (or feeling&amp;nbsp;adventurous).&lt;/p&gt;
&lt;p&gt;The &lt;a href="http://cgit.osmocom.org/rtl-sdr"&gt;rtl-sdr codebase&lt;/a&gt; (alternative &lt;a href="https://github.com/steve-m/librtlsdr"&gt;github mirror&lt;/a&gt;), curated by Osmocom is the backbone of the rtl-sdr community. It contains the code for both the rtlsdr.dll drivers (librtlsdr) and a number of command line utilities that use this library to perform a number of functions. Out of these we&amp;#8217;ll be mostly interested in &lt;strong&gt;rtl_test&lt;/strong&gt;, &lt;strong&gt;rtl_sdr&lt;/strong&gt; and &lt;strong&gt;rtl_fm&lt;/strong&gt; for now. The following sections will go into detail about each of these tools but for now let us focus on the main&amp;nbsp;library.&lt;/p&gt;
&lt;p&gt;The driver relies on libusb (which comes conveniently packed with the pre-built windows version but must be separately installed on Linux) to provide functions to interface with the &lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt; dongle. The functions it exports are what allow us to set the &lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt; dongle configuration parameters and read &lt;span class="caps"&gt;IQ&lt;/span&gt; samples. Some of these parameters are not exposed directly but are instead set through an internal algorithm. One possible reason for this is that the driver must support &lt;span class="caps"&gt;RTL&lt;/span&gt; dongles sporting a number of different tuner chips while providing a uniform tuner-agnostic interface. To give you an idea of the library&amp;#8217;s capabilities, the list that follows details the most relevant (for now) functions that it exports and what their implementations mean for dongles with a &lt;span class="caps"&gt;R820T&lt;/span&gt;/T2&amp;nbsp;tuner:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;rtlsdr_open/close&lt;/strong&gt;: opens the device and initializes it/closes the&amp;nbsp;device;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;rtlsdr_get_center_freq/set&lt;/strong&gt;: gets/sets the center frequency to tune to by configuring the tuner&amp;#8217;s &lt;span class="caps"&gt;PLL&lt;/span&gt; based frequency synthesizer to &lt;span class="math"&gt;\(f_c + f_{IF}\)&lt;/span&gt; (high-side&amp;nbsp;injection);&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;rtlsdr_get_freq_correction/set&lt;/strong&gt;: gets/sets the frequency correction parameter in parts per million&amp;nbsp;(ppm);&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;rtlsdr_get_tuner_type&lt;/strong&gt;: gets the tuner&amp;nbsp;type;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;rtlsdr_get_tuner_gains&lt;/strong&gt;: gets the list of supported gain values by the tuner. For the &lt;span class="caps"&gt;R820T&lt;/span&gt; this list is hardcoded and was determined experimentally. Its single parameter corresponds to all possible combinations of &lt;span class="caps"&gt;LNA&lt;/span&gt; and mixer gains as the &lt;span class="caps"&gt;VGA&lt;/span&gt; is always set to a fixed&amp;nbsp;value;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;rtlsdr_set_tuner_gain_mode&lt;/strong&gt;: sets the tuner gain mode to automatic (&lt;span class="caps"&gt;AGC&lt;/span&gt; is used for both &lt;span class="caps"&gt;LNA&lt;/span&gt; and mixer) or manual (gain value is provided manually through the next&amp;nbsp;function);&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;rtlsdr_get_tuner_gain/set&lt;/strong&gt;: gets/sets the tuner gains. For &lt;span class="caps"&gt;R820T&lt;/span&gt; it selects the &lt;span class="caps"&gt;LNA&lt;/span&gt; and mixer gains in order to provide a gain value as close as possible to the provided gain. &lt;span class="caps"&gt;VGA&lt;/span&gt; gain (&lt;span class="caps"&gt;IF&lt;/span&gt; gain) is set to a&amp;nbsp;constant;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;rtlsdr_set_tuner_if_gain&lt;/strong&gt;: sets &lt;span class="caps"&gt;IF&lt;/span&gt; gain. Unsuported for &lt;span class="caps"&gt;R820T&lt;/span&gt;;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;rtlsdr_set_tuner_bandwidth&lt;/strong&gt;: sets the tuner bandwidth through adjusting the &lt;span class="caps"&gt;IF&lt;/span&gt; filters. In practice, the list of supported values by the &lt;span class="caps"&gt;R820T&lt;/span&gt; tuner are 6, 7 and 8 MHz or a list of values ranging from 350 kHz to 2.43 MHz. The driver will always round upwards to the nearest supported value. The &lt;span class="caps"&gt;IF&lt;/span&gt; frequency used by the device is determined based on the bandwidth chosen with 4.57 MHz being used for 7 or 8 MHz bandwidth, 3.57 MHz for 6 MHz bandwidth and 2.3 MHz for any smaller bandwidth&amp;nbsp;values;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;rtlsdr_get_sample_rate/set&lt;/strong&gt;: gets/sets the sample rate of the rtl-sdr output to a value inside the allowed range of [225001; 300000] Hz âª [900001; 3200000] Hz. Also sets the bandwidth of the tuner to be the same as the sample rate if it wasn&amp;#8217;t set manually&amp;nbsp;before.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;rtlsdr_set_agc_mode&lt;/strong&gt;: sets the &lt;span class="caps"&gt;RTL2832U&lt;/span&gt; to use digital &lt;span class="caps"&gt;AGC&lt;/span&gt; (not the tuner&amp;#8217;s). This seems to amount only to simple fixed gain value being&amp;nbsp;applied;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;rtlsdr_read_sync&lt;/strong&gt;: reads a fixed number of interleaved 8-bit &lt;span class="caps"&gt;IQ&lt;/span&gt; samples from the device&amp;nbsp;synchronously;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;rtlsdr_read_async/cancel_async&lt;/strong&gt;: reads asynchronously from the device until cancel_async is&amp;nbsp;called.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It should be mentioned that, as with a lot of useful open source software, there exist a number of forks that seek to tweak and extend the capabilities of the rtl-sdr beyond what the standard drivers allow. Most of these should however be considered experimental. Two examples of such forks&amp;nbsp;are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/mutability/rtl-sdr/"&gt;mutability&amp;#8217;s&lt;/a&gt;: which extends the tuning range of the standard driver via a number of tricks involving manipulating the &lt;span class="caps"&gt;IF&lt;/span&gt; frequency and whether high or low-side injection is&amp;nbsp;used;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/keenerd/rtl-sdr"&gt;keenerd&amp;#8217;s&lt;/a&gt;: from the author of the rtl_fm and rtl_power command line tools which includes some modifications to the command line&amp;nbsp;utilities;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;&lt;/h1&gt;
&lt;h2&gt;rtl_test&lt;/h2&gt;
&lt;p&gt;We&amp;#8217;ll start our exploration of the rtl-sdr command tools with rtl_test. This is an utility that allows you to perform different tests on your &lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt; dongle and figure out the allowable ranges for some of the control parameters when capturing samples with your dongle. The following command will capture samples at 2.4 MHz and report any samples lost. You can suspend the program with Ctrl+C and it will tell you how many samples per million were&amp;nbsp;lost:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ rtl_test -s 2400000
Found &lt;span class="m"&gt;1&lt;/span&gt; device&lt;span class="o"&gt;(&lt;/span&gt;s&lt;span class="o"&gt;)&lt;/span&gt;:
  0:  Realtek, RTL2838UHIDIR, SN: 00000001

Using device 0: Generic RTL2832U OEM
Found Rafael Micro R820T tuner
Supported gain values &lt;span class="o"&gt;(&lt;/span&gt;29&lt;span class="o"&gt;)&lt;/span&gt;: 0.0 0.9 1.4 2.7 3.7 7.7 8.7 12.5 14.4 15.7 16.6 19.7 20.7
 22.9 25.4 28.0 29.7 32.8 33.8 36.4 37.2 38.6 40.2 42.1 43.4 43.9 44.5 48.0 49.6 
&lt;span class="o"&gt;[&lt;/span&gt;R82XX&lt;span class="o"&gt;]&lt;/span&gt; PLL not locked!
Sampling at &lt;span class="m"&gt;2400000&lt;/span&gt; S/s.

Info: This tool will continuously &lt;span class="nb"&gt;read&lt;/span&gt; from the device, and report &lt;span class="k"&gt;if&lt;/span&gt;
samples get lost. If you observe no further output, everything is fine.

Reading samples in async mode...
^CSignal caught, exiting!

User cancel, exiting...
Samples per million lost &lt;span class="o"&gt;(&lt;/span&gt;minimum&lt;span class="o"&gt;)&lt;/span&gt;: 0
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As you can see it will also report all the supported values for the gain setting of the tuner (see &lt;em&gt;rtlsdr_get_tuner_gains&lt;/em&gt;).  The &lt;span class="caps"&gt;PLL&lt;/span&gt; not locked message meaning that a lock was not achieved in the frequency synthesizer does not show up when running the program under windows and I&amp;#8217;m not sure what causes it. My NooElec &lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt; blog dongle is not dropping any samples at 2.4 MHz. You can try different settings of the sample rate with the &lt;strong&gt;-s&lt;/strong&gt; option within the allowable range (see &lt;em&gt;rtlsdr_set_sample_rate&lt;/em&gt; above) in order to figure out a maximum safe sample rate at which no samples are dropped (typically 2.56 MHz before the &lt;span class="caps"&gt;RTL2832U&lt;/span&gt; starts dropping samples internally). For instance, trying to sample at the known &amp;#8220;unsafe&amp;#8221; rate of 2.7 MHz&amp;nbsp;yields:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Sampling at &lt;span class="m"&gt;2700000&lt;/span&gt; S/s.

Info: This tool will continuously &lt;span class="nb"&gt;read&lt;/span&gt; from the device, and report &lt;span class="k"&gt;if&lt;/span&gt;
samples get lost. If you observe no further output, everything is fine.

Reading samples in async mode...
lost at least &lt;span class="m"&gt;68&lt;/span&gt; bytes
lost at least &lt;span class="m"&gt;68&lt;/span&gt; bytes
lost at least &lt;span class="m"&gt;68&lt;/span&gt; bytes
lost at least &lt;span class="m"&gt;68&lt;/span&gt; bytes
lost at least &lt;span class="m"&gt;188&lt;/span&gt; bytes
lost at least &lt;span class="m"&gt;256&lt;/span&gt; bytes
lost at least &lt;span class="m"&gt;68&lt;/span&gt; bytes
lost at least &lt;span class="m"&gt;188&lt;/span&gt; bytes
lost at least &lt;span class="m"&gt;68&lt;/span&gt; bytes
lost at least &lt;span class="m"&gt;68&lt;/span&gt; bytes
lost at least &lt;span class="m"&gt;68&lt;/span&gt; bytes
lost at least &lt;span class="m"&gt;68&lt;/span&gt; bytes
^CSignal caught, exiting!

User cancel, exiting...
Samples per million lost &lt;span class="o"&gt;(&lt;/span&gt;minimum&lt;span class="o"&gt;)&lt;/span&gt;: 11
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The tuner&amp;#8217;s local oscillator frequency can present a significant offset from reality due to the low quality crystal ocillator present in most dongles. Perhaps one of the most useful functions of rtl_test is measuring this error through the the &lt;strong&gt;-p&lt;/strong&gt; option which will report the frequency error in parts per million (&lt;span class="caps"&gt;PPM&lt;/span&gt;) as estimated (I think) from  tuning to &lt;span class="caps"&gt;GSM&lt;/span&gt; basestation signals of well known (high) frequency. These frequency errors will vary based on ambient temperature but are otherwise quite repeatable (even inter day). 
Letting it run for a few minutes should give you a somewhat reliable estimate that you can then use as the frequency correction parameter for other programs such as &lt;span class="caps"&gt;SDR&lt;/span&gt;# or rtl_sdr. The following is the result of running the program with the &lt;strong&gt;-p&lt;/strong&gt; option using my NooElec dongle directly after plugging it in (not warmed&amp;nbsp;up):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ rtl_test -s &lt;span class="m"&gt;2400000&lt;/span&gt; -p
Found &lt;span class="m"&gt;1&lt;/span&gt; device&lt;span class="o"&gt;(&lt;/span&gt;s&lt;span class="o"&gt;)&lt;/span&gt;:
  0:  Realtek, RTL2838UHIDIR, SN: 00000001

Using device 0: Generic RTL2832U OEM
Found Rafael Micro R820T tuner
Supported gain values &lt;span class="o"&gt;(&lt;/span&gt;29&lt;span class="o"&gt;)&lt;/span&gt;: 0.0 0.9 1.4 2.7 3.7 7.7 8.7 12.5 14.4 15.7 16.6 19.7 20.7
 22.9 25.4 28.0 29.7 32.8 33.8 36.4 37.2 38.6 40.2 42.1 43.4 43.9 44.5 48.0 49.6 
&lt;span class="o"&gt;[&lt;/span&gt;R82XX&lt;span class="o"&gt;]&lt;/span&gt; PLL not locked!
Sampling at &lt;span class="m"&gt;2400000&lt;/span&gt; S/s.
Reporting PPM error measurement every &lt;span class="m"&gt;10&lt;/span&gt; seconds...
Press ^C after a few minutes.
Reading samples in async mode...
real sample rate: &lt;span class="m"&gt;2400188&lt;/span&gt; current PPM: &lt;span class="m"&gt;78&lt;/span&gt; cumulative PPM: 78
real sample rate: &lt;span class="m"&gt;2400164&lt;/span&gt; current PPM: &lt;span class="m"&gt;69&lt;/span&gt; cumulative PPM: 73
real sample rate: &lt;span class="m"&gt;2400190&lt;/span&gt; current PPM: &lt;span class="m"&gt;80&lt;/span&gt; cumulative PPM: 75
real sample rate: &lt;span class="m"&gt;2400153&lt;/span&gt; current PPM: &lt;span class="m"&gt;64&lt;/span&gt; cumulative PPM: 73
real sample rate: &lt;span class="m"&gt;2400151&lt;/span&gt; current PPM: &lt;span class="m"&gt;63&lt;/span&gt; cumulative PPM: 71
real sample rate: &lt;span class="m"&gt;2400153&lt;/span&gt; current PPM: &lt;span class="m"&gt;64&lt;/span&gt; cumulative PPM: 70
real sample rate: &lt;span class="m"&gt;2400159&lt;/span&gt; current PPM: &lt;span class="m"&gt;66&lt;/span&gt; cumulative PPM: 69
real sample rate: &lt;span class="m"&gt;2400177&lt;/span&gt; current PPM: &lt;span class="m"&gt;74&lt;/span&gt; cumulative PPM: 70
real sample rate: &lt;span class="m"&gt;2400157&lt;/span&gt; current PPM: &lt;span class="m"&gt;66&lt;/span&gt; cumulative PPM: 69
real sample rate: &lt;span class="m"&gt;2400163&lt;/span&gt; current PPM: &lt;span class="m"&gt;68&lt;/span&gt; cumulative PPM: 69
real sample rate: &lt;span class="m"&gt;2400150&lt;/span&gt; current PPM: &lt;span class="m"&gt;63&lt;/span&gt; cumulative PPM: 69
real sample rate: &lt;span class="m"&gt;2400197&lt;/span&gt; current PPM: &lt;span class="m"&gt;82&lt;/span&gt; cumulative PPM: 70
real sample rate: &lt;span class="m"&gt;2400155&lt;/span&gt; current PPM: &lt;span class="m"&gt;65&lt;/span&gt; cumulative PPM: 69
real sample rate: &lt;span class="m"&gt;2400144&lt;/span&gt; current PPM: &lt;span class="m"&gt;60&lt;/span&gt; cumulative PPM: 69
real sample rate: &lt;span class="m"&gt;2400165&lt;/span&gt; current PPM: &lt;span class="m"&gt;69&lt;/span&gt; cumulative PPM: 69
real sample rate: &lt;span class="m"&gt;2400150&lt;/span&gt; current PPM: &lt;span class="m"&gt;63&lt;/span&gt; cumulative PPM: 68
real sample rate: &lt;span class="m"&gt;2400169&lt;/span&gt; current PPM: &lt;span class="m"&gt;71&lt;/span&gt; cumulative PPM: 68
real sample rate: &lt;span class="m"&gt;2400166&lt;/span&gt; current PPM: &lt;span class="m"&gt;70&lt;/span&gt; cumulative PPM: 68
real sample rate: &lt;span class="m"&gt;2400164&lt;/span&gt; current PPM: &lt;span class="m"&gt;69&lt;/span&gt; cumulative PPM: 69
^CSignal caught, exiting!

User cancel, exiting...
Samples per million lost &lt;span class="o"&gt;(&lt;/span&gt;minimum&lt;span class="o"&gt;)&lt;/span&gt;: 0
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The results I get from my rtl-sdr.com dongle paint a very different picture owing to it&amp;#8217;s much more accurate 1 &lt;span class="caps"&gt;PPM&lt;/span&gt; temperature compensated oscillator. After plugging in the dongle the cumulative frequency error quickly drops to a much smaller&amp;nbsp;value:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;real sample rate: &lt;span class="m"&gt;2400001&lt;/span&gt; current PPM: &lt;span class="m"&gt;1&lt;/span&gt; cumulative PPM: 1
real sample rate: &lt;span class="m"&gt;2399958&lt;/span&gt; current PPM: -17 cumulative PPM: -8
real sample rate: &lt;span class="m"&gt;2400060&lt;/span&gt; current PPM: &lt;span class="m"&gt;25&lt;/span&gt; cumulative PPM: 3
real sample rate: &lt;span class="m"&gt;2399996&lt;/span&gt; current PPM: -2 cumulative PPM: 2
real sample rate: &lt;span class="m"&gt;2400014&lt;/span&gt; current PPM: &lt;span class="m"&gt;6&lt;/span&gt; cumulative PPM: 3
real sample rate: &lt;span class="m"&gt;2399948&lt;/span&gt; current PPM: -21 cumulative PPM: -1
real sample rate: &lt;span class="m"&gt;2400026&lt;/span&gt; current PPM: &lt;span class="m"&gt;11&lt;/span&gt; cumulative PPM: 0
real sample rate: &lt;span class="m"&gt;2400005&lt;/span&gt; current PPM: &lt;span class="m"&gt;2&lt;/span&gt; cumulative PPM: 1
real sample rate: &lt;span class="m"&gt;2400072&lt;/span&gt; current PPM: &lt;span class="m"&gt;30&lt;/span&gt; cumulative PPM: 4
real sample rate: &lt;span class="m"&gt;2399939&lt;/span&gt; current PPM: -25 cumulative PPM: 1
real sample rate: &lt;span class="m"&gt;2400011&lt;/span&gt; current PPM: &lt;span class="m"&gt;5&lt;/span&gt; cumulative PPM: 1
real sample rate: &lt;span class="m"&gt;2399996&lt;/span&gt; current PPM: -1 cumulative PPM: 1
real sample rate: &lt;span class="m"&gt;2400017&lt;/span&gt; current PPM: &lt;span class="m"&gt;7&lt;/span&gt; cumulative PPM: 2
real sample rate: &lt;span class="m"&gt;2399950&lt;/span&gt; current PPM: -21 cumulative PPM: 0
real sample rate: &lt;span class="m"&gt;2400030&lt;/span&gt; current PPM: &lt;span class="m"&gt;13&lt;/span&gt; cumulative PPM: 1
real sample rate: &lt;span class="m"&gt;2400010&lt;/span&gt; current PPM: &lt;span class="m"&gt;5&lt;/span&gt; cumulative PPM: 1
real sample rate: &lt;span class="m"&gt;2399982&lt;/span&gt; current PPM: -7 cumulative PPM: 1
real sample rate: &lt;span class="m"&gt;2400030&lt;/span&gt; current PPM: &lt;span class="m"&gt;13&lt;/span&gt; cumulative PPM: 1
real sample rate: &lt;span class="m"&gt;2399995&lt;/span&gt; current PPM: -2 cumulative PPM: 1
real sample rate: &lt;span class="m"&gt;2400004&lt;/span&gt; current PPM: &lt;span class="m"&gt;2&lt;/span&gt; cumulative PPM: 1
real sample rate: &lt;span class="m"&gt;2400019&lt;/span&gt; current PPM: &lt;span class="m"&gt;8&lt;/span&gt; cumulative PPM: 1
real sample rate: &lt;span class="m"&gt;2399954&lt;/span&gt; current PPM: -19 cumulative PPM: 1
real sample rate: &lt;span class="m"&gt;2400013&lt;/span&gt; current PPM: &lt;span class="m"&gt;5&lt;/span&gt; cumulative PPM: 1
&lt;/pre&gt;&lt;/div&gt;


&lt;!---   real sample rate: 2400012 current PPM: 5 cumulative PPM: 1
    real sample rate: 2400003 current PPM: 1 cumulative PPM: 1
    real sample rate: 2400013 current PPM: 6 cumulative PPM: 1
    real sample rate: 2400004 current PPM: 2 cumulative PPM: 1
    real sample rate: 2399978 current PPM: -9 cumulative PPM: 1
    real sample rate: 2400002 current PPM: 1 cumulative PPM: 1
    real sample rate: 2400029 current PPM: 12 cumulative PPM: 1
    real sample rate: 2399986 current PPM: -6 cumulative PPM: 1
    real sample rate: 2399996 current PPM: -1 cumulative PPM: 1
    real sample rate: 2400014 current PPM: 6 cumulative PPM: 1
    real sample rate: 2399992 current PPM: -3 cumulative PPM: 1
    real sample rate: 2400019 current PPM: 8 cumulative PPM: 1
    real sample rate: 2399971 current PPM: -12 cumulative PPM: 1
    real sample rate: 2400010 current PPM: 4 cumulative PPM: 1
    real sample rate: 2400001 current PPM: 0 cumulative PPM: 1
    real sample rate: 2400011 current PPM: 5 cumulative PPM: 1
    real sample rate: 2400038 current PPM: 16 cumulative PPM: 1
    real sample rate: 2399927 current PPM: -30 cumulative PPM: 1
    real sample rate: 2400016 current PPM: 7 cumulative PPM: 1
    real sample rate: 2400005 current PPM: 2 cumulative PPM: 1
    real sample rate: 2400005 current PPM: 2 cumulative PPM: 1
    real sample rate: 2400012 current PPM: 5 cumulative PPM: 1
    real sample rate: 2399996 current PPM: -1 cumulative PPM: 1
    real sample rate: 2400059 current PPM: 25 cumulative PPM: 1
    real sample rate: 2399902 current PPM: -41 cumulative PPM: 0
    real sample rate: 2400034 current PPM: 14 cumulative PPM: 1
    real sample rate: 2400005 current PPM: 2 cumulative PPM: 1
    real sample rate: 2400003 current PPM: 1 cumulative PPM: 1
    real sample rate: 2400007 current PPM: 3 cumulative PPM: 1
    real sample rate: 2399998 current PPM: -1 cumulative PPM: 1
    real sample rate: 2399985 current PPM: -6 cumulative PPM: 1
    real sample rate: 2400005 current PPM: 2 cumulative PPM: 1
    real sample rate: 2400005 current PPM: 2 cumulative PPM: 1
    real sample rate: 2400006 current PPM: 3 cumulative PPM: 1
---&gt;

&lt;p&gt;I should mention that I get no &lt;span class="caps"&gt;PPM&lt;/span&gt; reports from running rtl_test under windows and again I&amp;#8217;m not sure&amp;nbsp;why&amp;#8230;&lt;/p&gt;
&lt;h2&gt;rtl_fm&lt;/h2&gt;
&lt;p&gt;rtl_fm is a very resource efficient command line tool to capture &lt;span class="caps"&gt;IQ&lt;/span&gt; samples from the &lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt; and demodulate &lt;span class="caps"&gt;FM&lt;/span&gt;, &lt;span class="caps"&gt;AM&lt;/span&gt; and &lt;span class="caps"&gt;SSB&lt;/span&gt; signals. For more information on this program make sure to check the &lt;a href="http://kmkeen.com/rtl-demod-guide/"&gt;rtl_fm guide&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The following command will demodulate and record a wideband &lt;span class="caps"&gt;FM&lt;/span&gt; channel at 97.4 MHz and record it in a file &lt;em&gt;comercial.raw&lt;/em&gt;. You can press Ctrl+C to exit after capturing enough&amp;nbsp;samples.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ rtl_fm -M wbfm -f 97.4M -g &lt;span class="m"&gt;20&lt;/span&gt; comercial.raw
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The meaning of the options&amp;nbsp;is:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;-M wbfm&lt;/strong&gt;: wideband &lt;span class="caps"&gt;FM&lt;/span&gt;&amp;nbsp;modulation;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-f 97.4M&lt;/strong&gt;: center frequency of 97.4&amp;nbsp;MHz;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-g 20&lt;/strong&gt;: sets the tuner gain to the closest allowable value to 20 dB (19.7 dB). Without this option present automatic gain is&amp;nbsp;used.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;when using -M wbfm a few implicit options are assumed (which can be explicitely&amp;nbsp;overriden):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;-s 170k&lt;/strong&gt;: for wideband &lt;span class="caps"&gt;FM&lt;/span&gt; a sample rate of 170 kHz is chosen by&amp;nbsp;default;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-A fast&lt;/strong&gt;: fast polynomial approximation of arctangent used in&amp;nbsp;demodulation;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-r 32k&lt;/strong&gt;: output is decimated to 32&amp;nbsp;kHz;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-l 0&lt;/strong&gt;: disables&amp;nbsp;squelch;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-E deemp&lt;/strong&gt;: applies a deemphesis&amp;nbsp;filter.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The output I get running this command and then stopping the execution after a few seconds&amp;nbsp;is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Found &lt;span class="m"&gt;1&lt;/span&gt; device&lt;span class="o"&gt;(&lt;/span&gt;s&lt;span class="o"&gt;)&lt;/span&gt;:
  0:  Realtek, RTL2838UHIDIR, SN: 00000001

Using device 0: Generic RTL2832U OEM
Found Rafael Micro R820T tuner
Tuner gain &lt;span class="nb"&gt;set&lt;/span&gt; to 19.70 dB.
Tuned to &lt;span class="m"&gt;97671000&lt;/span&gt; Hz.
Oversampling input by: 6x.
Oversampling output by: 1x.
Buffer size: 8.03ms
Exact sample rate is: 1020000.026345 Hz
Sampling at &lt;span class="m"&gt;1020000&lt;/span&gt; S/s.
Output at &lt;span class="m"&gt;170000&lt;/span&gt; Hz.
Signal caught, exiting!
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You might notice that rtl_fm tuned to a different frequency (97.671 MHz) than that we specified (97.4 MHz). This is done to avoid the &lt;span class="caps"&gt;DC&lt;/span&gt; bias that is present in dongles with Zero-&lt;span class="caps"&gt;IF&lt;/span&gt; tuners such as the e4000. This way the dongle is tuned to a slightly different frequency in order to avoid the &lt;span class="caps"&gt;DC&lt;/span&gt; spike and the software later corrects for this in the digital signal processing by shifting the captured signal in frequency to 0 Hz. While this shouldn&amp;#8217;t be necessary for &lt;span class="caps"&gt;R820T&lt;/span&gt; tuners one might argue that it&amp;#8217;s still justified in case there is any significant flicker noise (1/f psd) or higher power law noises present at the&amp;nbsp;output.&lt;/p&gt;
&lt;p&gt;Notice also that the software oversamples by 6x at 1.02 MHz and then decimates the output to the (implicitely) specified frequency of 170 kHz before demodulating. This is because, first and foremost, 170 kHz is not a valid sampling frequency for the &lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt; (see the librtlsdr section above for the valid range). 1.02 MHz is in fact the first integer multiple of 170 kHz that fits in the allowed range. But this is not the only reason; in fact if we specifically ask rtl_fm to sample the input at 240 kHz with &lt;strong&gt;-s 240k&lt;/strong&gt;, it will still oversample by 5x at 1.2 MHz despite the fact that 240 kHz is within the allowed range of sampling frequencies of the &lt;span class="caps"&gt;RTL&lt;/span&gt; &lt;span class="caps"&gt;SDR&lt;/span&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Oversampling input by: 5x.
Oversampling output by: 1x.
Buffer size: 6.83ms
Sampling at &lt;span class="m"&gt;1200000&lt;/span&gt; S/s.
Output at &lt;span class="m"&gt;240000&lt;/span&gt; Hz.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;My assumption is that this is done in order to mitigate the quantization noise. Recall that the output of the &lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt; is 8 bits and therefore oversampling and decimating in software where we&amp;#8217;re not limited to 8 bits should provide a better noise figure than relying on doing the decimation in the chip. Furthermore, it provides greater control over the decimation process, letting the software choose the low-pass filter. From these considerations it would make sense to always use the highest possible sampling rate but rtl_fm is built with limited resources in mind so that might provide a reason for it compromising for sampling frequencies closer to 1&amp;nbsp;MHz.&lt;/p&gt;
&lt;p&gt;rtl_fm stores the raw audio in a file as signed 16 bits integers. To load it in python with numpy you can therefore&amp;nbsp;do:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;numpy&lt;/span&gt; &lt;span class="kn"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;np&lt;/span&gt;

&lt;span class="n"&gt;raw_audio&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fromfile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;comercial.raw&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;int16&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;To listen to it you can always use scipy to store it as a .wav file and then play it in your favourite media&amp;nbsp;player:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;scipy.io&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;wavfile&lt;/span&gt;

&lt;span class="n"&gt;wavfile&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;comercial.wav&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rate&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;32000&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;raw_audio&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Recall that the default output rate of rtl_fm in wideband &lt;span class="caps"&gt;FM&lt;/span&gt; mode is 32 kHz but if you changed that with the -r option make sure to provide wavfile.write with the correct one (and that it is within the allowed range of your sound&amp;nbsp;card&amp;#8230;).&lt;/p&gt;
&lt;p&gt;&lt;div class="audio-container"&gt;&lt;audio controls&gt;&lt;source src="/audio/comercial.wav" type="audio/wav"&gt;Your browser does not support the audio element.&lt;/audio&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;Alternativelly you could install and use &lt;a href="http://sox.sourceforge.net/"&gt;SoX&lt;/a&gt; which is a great program to convert audio files between formats (including raw audio signals), as well as playing and recording them. The following command will play the raw audio file with sample rate 32 kHz, 16 bits signed int encoding and 1 channel on my windows&amp;nbsp;machine:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sox -r 32k -t raw -e signed -b &lt;span class="m"&gt;16&lt;/span&gt; -c &lt;span class="m"&gt;1&lt;/span&gt; comercial.raw -t waveaudio
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You can replace &amp;#8220;-t waveaudio&amp;#8221; with a .wav filename to store it in a wav file instead. Make sure to refer to &lt;a href="http://sox.sourceforge.net/sox.html"&gt;SoX&amp;#8217;s documentation&lt;/a&gt; for a full description of the options&amp;nbsp;available.&lt;/p&gt;
&lt;h2&gt;rtl_sdr&lt;/h2&gt;
&lt;p&gt;Finally, the most general use command line tool in the rtl-sdr package is rtl_sdr. This program will let you capture &lt;span class="caps"&gt;IQ&lt;/span&gt; samples directly and store them in a file (or pipe them into some other command line&amp;nbsp;application):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ rtl_sdr -f &lt;span class="m"&gt;97400000&lt;/span&gt; -g &lt;span class="m"&gt;20&lt;/span&gt; -s &lt;span class="m"&gt;2400000&lt;/span&gt; -n &lt;span class="m"&gt;24000000&lt;/span&gt; comercial_s2m4_g20.dat
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The options in this case&amp;nbsp;mean:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;-f 97400000&lt;/strong&gt;: sets the tuner frequency to 97.4&amp;nbsp;MHz;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-g 20&lt;/strong&gt;: sets the tuner gain to the closest allowable value to 20 dB (19.7&amp;nbsp;dB);&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-s 2400000&lt;/strong&gt;: sets the sample rate to 2.4&amp;nbsp;MHz;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-n 24000000&lt;/strong&gt;: instructs rtl_sdr to capture 2.4e7 samples which should amount to a 10 seconds worth of samples at the given sample rate (10 s * 2.4e6&amp;nbsp;MHz).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This utility stores the I and Q samples alternately as 8 bits unsigned integers. In order to load them in python we can therefore use something&amp;nbsp;like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;numpy&lt;/span&gt; &lt;span class="kn"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;np&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;load_iq&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fromfile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;uint8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;int8&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;127&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;#adding a signed int8 to an unsigned one results in an int16 array&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;astype&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;int8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reshape&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;    &lt;span class="c1"&gt;#we cast it back to an int8 array and reshape&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This will load the file and return an numpy.int8 numpy array with shape (nsamples, 2), the first column corresponding to I samples and the second to Q&amp;nbsp;samples.&lt;/p&gt;
&lt;p&gt;A more convenient format to process the data digitally is to load it as complex samples (I + j*Q). Unfortunately numpy doesn&amp;#8217;t have a complex integer type so we&amp;#8217;ll have to incur in a bit of memory overhead and spring for a numpy.complex64 array which makes it less useful when dealing with a large number of&amp;nbsp;samples:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;load_iq_complex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fromfile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;uint8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;float32&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;127.5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;#by subtracting a float32 the resulting array will also be float32&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mf"&gt;8e-3&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;view&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;complex64&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                        &lt;span class="c1"&gt;#viewing it as a complex64 array then yields the correct result&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;&lt;/h1&gt;
&lt;h1&gt;pyrtlsdr&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://github.com/roger-/pyrtlsdr"&gt;pyrtlsdr&lt;/a&gt; is a python library that wraps the rtlsdr.dll library functions and provides you an object oriented &lt;span class="caps"&gt;API&lt;/span&gt; to access them. You can install it using pip since I&amp;#8217; don&amp;#8217;t think it&amp;#8217;s available through conda. You also need to make sure that the rtlsdr.dll is in your python path. If you don&amp;#8217;t want to edit it on windows you can always just drop a copy of the necessary dlls into your working&amp;nbsp;folder&amp;#8230;&lt;/p&gt;
&lt;p&gt;If you want you can access directly the librtlsdr wrapper functions through importing the librtlsdr submodule. You&amp;#8217;ll have to initialize a pointer to the device that you then pass to all the librtlsdr functions. In order to open an rtl-sdr device for instance you could&amp;nbsp;do:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;rtlsdr.librtlsdr&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;librtlsdr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;p_rtlsdr_dev&lt;/span&gt;

&lt;span class="n"&gt;dev_p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;p_rtlsdr_dev&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;             &lt;span class="c1"&gt;#the device pointer&lt;/span&gt;
&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;librtlsdr&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rtlsdr_open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dev_p&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;#opens device at index 0&lt;/span&gt;
                                   &lt;span class="c1"&gt;#returns an integer &amp;lt; 0 on error&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This is however not the intended use of the library. It defines a much more convenient RtlSdr class which stores the device pointer (and a few other useful variables) and wraps all the functions as methods so that a much more pythonic &lt;span class="caps"&gt;API&lt;/span&gt; is exposed. Most of these methods will have the same name as the original librtlsdr function minus the &lt;em&gt;rtlsdr_&lt;/em&gt; prefix (a notable exception being the methods to read the samples). It also defines a few notable properties that can be used to call the get/set methods in a more idiomatic&amp;nbsp;way:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;center_freq;&lt;/li&gt;
&lt;li&gt;sample_rate;&lt;/li&gt;
&lt;li&gt;gain;&lt;/li&gt;
&lt;li&gt;freq_correction;&lt;/li&gt;
&lt;li&gt;bandwidth.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To collect 10 seconds of data with the same characteristics as that we collected with rtl_sdr we would&amp;nbsp;do:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;rtlsdr&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;RtlSdr&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;contextlib&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;closing&lt;/span&gt;

&lt;span class="c1"&gt;#we use a context manager that automatically calls .close() on sdr&lt;/span&gt;
&lt;span class="c1"&gt;#whether the code block finishes successfully or an error occurs&lt;/span&gt;
&lt;span class="c1"&gt;#initializing a RtlSdr instance automatically calls open()&lt;/span&gt;
&lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;closing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;RtlSdr&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;sdr&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
    &lt;span class="n"&gt;sdr&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sample_rate&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sample_rate&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2400000&lt;/span&gt;
    &lt;span class="n"&gt;sdr&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;center_freq&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;97.4e6&lt;/span&gt;
    &lt;span class="n"&gt;sdr&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gain&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;
    &lt;span class="n"&gt;iq_samples&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sdr&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read_samples&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;sample_rate&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;&lt;/h1&gt;
&lt;h1&gt;Demodulating &lt;span class="caps"&gt;FM&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;Armed with our new found knowledge of how to capture &lt;span class="caps"&gt;IQ&lt;/span&gt; samples and load them into python we can finally get working on demodulating &lt;span class="caps"&gt;FM&lt;/span&gt; signals. We will first plot the Welch power spectral density (&lt;span class="caps"&gt;PSD&lt;/span&gt;) estimate of the complex baseband representation obtained in either of the two previous&amp;nbsp;sections:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;scipy&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;signal&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;scipy.fftpack&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;fftshift&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;matplotlib.pyplot&lt;/span&gt; &lt;span class="kn"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;plt&lt;/span&gt;

&lt;span class="c1"&gt;#compute Welch estimate without detrending&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Pxx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;welch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;iq_samples&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sample_rate&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;detrend&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Pxx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fftshift&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;fftshift&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Pxx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;semilogy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mf"&gt;1e3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Pxx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;xlabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;f [kHz]&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ylabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;PSD [Power/Hz]&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;grid&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;xticks&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;linspace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;sample_rate&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mf"&gt;2e3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sample_rate&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mf"&gt;2e3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;xlim&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;sample_rate&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mf"&gt;2e3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sample_rate&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mf"&gt;2e3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="Whole spectrum" src="http://ajoo.blog/images/pwelch_whole.png"&gt;&lt;/p&gt;
&lt;p&gt;The first thing you should notice is that I have massively oversampled the &lt;span class="caps"&gt;FM&lt;/span&gt; signal. Recall that at a sample rate of 2.4 MHz we&amp;#8217;re seeing a portion of the spectrum ranging from 97.4 MHz +- 1.2 MHz. The bandwidth of a comercial &lt;span class="caps"&gt;FM&lt;/span&gt; radio station however is usually around 200 kHz and the two peaks to the left and right of the main one are actually 2 different stations with a weaker&amp;nbsp;signal.&lt;/p&gt;
&lt;p&gt;Oversampling the signal we want has an advantage which I touched upon in the rtl_fm section but I&amp;#8217;ll reiterate here. Because the &lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt; &lt;span class="caps"&gt;ADC&lt;/span&gt; is 8 bit there will be significant quantization noise. Oversampling and decimating in software where the 8-bit limitation doesn&amp;#8217;t exist should yield a better &lt;span class="caps"&gt;SNR&lt;/span&gt; figure. I assume that this is the reason that &lt;span class="caps"&gt;SDR&lt;/span&gt;# also samples at 2.4 MHz by default when listening to &lt;span class="caps"&gt;FM&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;As to the other stations, we could have gotten rid of them by setting our &lt;span class="caps"&gt;IF&lt;/span&gt; filter bandwidth smaller. It was automatically set by the driver at 2.4 MHz when we set the sample rate and I chose not to manually set it lower because I wanted these other signals to show up in order to illustrate a point further along. Adjusting your &lt;span class="caps"&gt;IF&lt;/span&gt; filter to the bandwidth of the signal you&amp;#8217;re interested in when oversampling is probably a good idea since more selectivity is always&amp;nbsp;good.&lt;/p&gt;
&lt;p&gt;We&amp;#8217;re now ready to decimate the signal down to a more manageable rate of 240 kHz which is a bit more than the bandwidth of the signal we&amp;#8217;re interested in but makes the decimation math simpler. We&amp;#8217;ll let the decimation filter take care of the unwanted stations and out of band&amp;nbsp;noise:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;sample_rate_fm&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;240000&lt;/span&gt;                       &lt;span class="c1"&gt;#decimate by 10&lt;/span&gt;
&lt;span class="n"&gt;iq_comercial&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;decimate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;iq_samples&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sample_rate&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;sample_rate_fm&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As you can see the &lt;span class="caps"&gt;PSD&lt;/span&gt; estimate now contains only the signal of interest which is the broadcast by &lt;span class="caps"&gt;FM&lt;/span&gt; station RÃ¡dio&amp;nbsp;Comercial:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Comercial spectrum" src="http://ajoo.blog/images/pwelch_comercial.png"&gt;&lt;/p&gt;
&lt;p&gt;We can now proceed with the demodulation. Going back to the &lt;a href="http://ajoo.blog/intro-to-rtl-sdr-part-i-principles-and-hardware.html#Frequency Demodulation"&gt;section on &lt;span class="caps"&gt;FM&lt;/span&gt; modulation&lt;/a&gt; of the first part of this introduction we find that in order to demodulate an &lt;span class="caps"&gt;FM&lt;/span&gt; signal from it&amp;#8217;s complex baseband representation, it suffices to differentiate the angle of the&amp;nbsp;signal:&lt;/p&gt;
&lt;div class="math"&gt;$$\frac{\text{d}\angle s_b(t)}{\text{d}t} = 2\pi f_\Delta m(t)$$&lt;/div&gt;
&lt;p&gt;In discrete-time this can be accomplished through a differentiating &lt;span class="caps"&gt;FIR&lt;/span&gt; filter. For the sake of simplicity we&amp;#8217;ll use the simple forward difference &lt;span class="math"&gt;\(\left(1-q^{-1}\right)\)&lt;/span&gt; through numpy&amp;#8217;s &lt;em&gt;diff&lt;/em&gt;&amp;nbsp;function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;angle_comercial&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;unwrap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;angle&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;iq_comercial&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;demodulated_comercial&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;diff&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;angle_comercial&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We unwrap the result of the angle function to remove &lt;span class="math"&gt;\(2\pi\)&lt;/span&gt; discontinuities. Differentiating this angle then yields the desired result with one caveat, the sample rate of the signal is too high for the typical sound card (and effectivelly our ears which in the best of cases can pick up to 20 kHz). A further decimation is thus necessary to bring the signal down to a sample rate that our sound cards can reproduce. 48 kHz is a good value for this as it is supported by most sound&amp;nbsp;cards:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;audio_rate&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;48000&lt;/span&gt;
&lt;span class="n"&gt;audio_comercial&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;decimate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;demodulated_comercial&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; \
    &lt;span class="n"&gt;sample_rate_fm&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;audio_rate&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;zero_phase&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The following is the final result after converting to a 16-bit per sample wav file (for the sake of some compression since 16-bit is more than necessary for a decent audio&amp;nbsp;quality):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;audio_comercial&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;int16&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1e4&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;audio_comercial&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;wavfile&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;comercial_demodulated.wav&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rate&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;audio_rate&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;audio_comercial&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;div class="audio-container"&gt;&lt;audio controls&gt;&lt;source src="/audio/comercial_demodulated.wav" type="audio/wav"&gt;Your browser does not support the audio element.&lt;/audio&gt;&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;Tuning to a Different&amp;nbsp;Station&lt;/h2&gt;
&lt;p&gt;The interesting thing about &lt;span class="caps"&gt;SDR&lt;/span&gt; is that we can do anything with the captured signal. Since we oversampled the signal so much that we actually picked up additional &lt;span class="caps"&gt;FM&lt;/span&gt; broadcasts we can tune into these in software and see if they yield something more&amp;nbsp;interesting.&lt;/p&gt;
&lt;p&gt;Recall that multiplying by a complex sinusoid correspondes to circularly shifting the spectrum of the digital signal by that sinusoid&amp;#8217;s&amp;nbsp;frequency:&lt;/p&gt;
&lt;div class="math"&gt;$$e^{j\omega_0n}x[n]\stackrel{\mathrm{DFT}}{\longleftrightarrow}X\left(e^{j(\omega+\omega_0)}\right)
$$&lt;/div&gt;
&lt;p&gt;We can use this to center the station 800 kHz to the left of RÃ¡dio Comercial which is the frequency for Smooth &lt;span class="caps"&gt;FM&lt;/span&gt; (96.6 MHz). All we need to do is multiply our complex baseband samples by &lt;span class="math"&gt;\(e^{j\frac{2\pi}{3}n}\)&lt;/span&gt; since &lt;span class="math"&gt;\(1/3\)&lt;/span&gt; is the required normalized frequency (&lt;span class="math"&gt;\(\frac{800\;kHz}{f_s}\)&lt;/span&gt;):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;f_shift&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;800000&lt;/span&gt;
&lt;span class="n"&gt;iq_shifted&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;iq_samples&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;\
    &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1j&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;f_shift&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;sample_rate&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;arange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;iq_samples&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We can then decimate the resulting signal in order to obtain the complex baseband representation of the &lt;span class="caps"&gt;FM&lt;/span&gt; broadcast of Smooth &lt;span class="caps"&gt;FM&lt;/span&gt; in the same fashion as we did for RÃ¡dio Comercial. The &lt;span class="caps"&gt;PSD&lt;/span&gt; estimate of the 3 signals is depicted next for&amp;nbsp;comparison:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Comercial spectrum" src="http://ajoo.blog/images/pwelch_smooth.png"&gt;&lt;/p&gt;
&lt;p&gt;Demodulation can then be done in the same way yielding the following&amp;nbsp;result:&lt;/p&gt;
&lt;p&gt;&lt;div class="audio-container"&gt;&lt;audio controls&gt;&lt;source src="/audio/smooth_demodulated.wav" type="audio/wav"&gt;Your browser does not support the audio element.&lt;/audio&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;We can see that this example is a bit noisier owing to the roughly 100-fold less power of the received signal. However it&amp;#8217;s pretty much still audible which only speaks to the frequency modulation&amp;#8217;s noise&amp;nbsp;tolerance.&lt;/p&gt;
&lt;p&gt;What we&amp;#8217;ve done here is essentially another digital downconversion similar to the one done inside the &lt;span class="caps"&gt;RTL2832U&lt;/span&gt; to get from &lt;span class="caps"&gt;IF&lt;/span&gt; to baseband. We now know how to easily perform these frequency shifts in software and the same principle can be applied for different purposes such as performing a frequency correction directly in software or tuning the &lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt; a bit off-frequency to avoid a possible &lt;span class="caps"&gt;DC&lt;/span&gt; spike and then correct for this in software like rtl_fm&amp;nbsp;does.&lt;/p&gt;
&lt;!&amp;#8212;-[DSP Tricks](http://www.embedded.com/design/configurable-systems/4212086/DSP-Tricks&amp;#8212;Frequency-demodulation-algorithms-)&amp;#8212;-&gt;

&lt;h1&gt;Up&amp;nbsp;Next&lt;/h1&gt;
&lt;p&gt;My next posts will be an introduction to &lt;span class="caps"&gt;GNU&lt;/span&gt; radio where I&amp;#8217;ll demodulate &lt;span class="caps"&gt;FM&lt;/span&gt; signals in real time and another which will provide a brief overview to the &lt;span class="caps"&gt;GPS&lt;/span&gt; system and sampling of &lt;span class="caps"&gt;GPS&lt;/span&gt; L1 signals. Stay&amp;nbsp;tuned!&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="RTL-SDR"></category><category term="Python"></category><category term="DSP"></category></entry><entry><title>Intro to RTL-SDR, Part I - Principles andÂ Hardware</title><link href="http://ajoo.blog/intro-to-rtl-sdr-part-i-principles-and-hardware.html" rel="alternate"></link><published>2017-01-25T18:00:00+00:00</published><updated>2017-01-26T23:55:00+00:00</updated><author><name>Ajoo</name></author><id>tag:ajoo.blog,2017-01-25:/intro-to-rtl-sdr-part-i-principles-and-hardware.html</id><summary type="html">&lt;p&gt;A summary of what I&amp;#8217;ve learned about &lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt; so far. From the working principles of the &lt;span class="caps"&gt;USB&lt;/span&gt; dongles to the software I intend to use to capture and process the data for future&amp;nbsp;projects.&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;div class="figure"&gt;
	&lt;img src="http://ajoo.blog/external_images/nesdr_mini_2.png" width="500" alt="NooElec RTL-SDR"&gt;
	&lt;p class="caption"&gt;NooElec &lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt; &lt;span class="caps"&gt;USB&lt;/span&gt; dongle. &lt;a href=http://www.nooelec.com/store/sdr/sdr-receivers/nesdr-mini-rtl2832-r820t.html&gt;Image&amp;nbsp;source&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The purpose of this article is to introduce a small and cheap device that is quickly becoming a staple of the modern radiofrequency enthusiast&amp;#8217;s toolbox. Initially this two-part introduction to &lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt; was meant as a single blog post. I intended to first go through the theory and working principles of the hardware and then move on to the software that I plan to use in future &lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt; projects. Finally, I intended to use this software to implement a simple &lt;span class="caps"&gt;FM&lt;/span&gt; demodulator in order to illustrate my points through a practical&amp;nbsp;application.&lt;/p&gt;
&lt;p&gt;The more I researched this topic however, the more things I found that I wanted to write about here and this post eventually grew to be too lengthy for a single serving. I wanted this first article to be quite in depth, especially regarding the inner workings of &lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt; dongles because I wanted to have a single point to refer back to on this matter, both for my sake and that of any readers out&amp;nbsp;there.&lt;/p&gt;
&lt;p&gt;As such, in this first part of my introduction to &lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt; I&amp;#8217;ll go over some basic principles of telecommunications that I feel are essential in order to understand the working principles of &lt;span class="caps"&gt;SDR&lt;/span&gt; hardware. I will then describe the components that make up the &lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt; and explain their&amp;nbsp;functioning. &lt;/p&gt;
&lt;p&gt;This means that this first part is mostly theoretical but I hope that doesn&amp;#8217;t deter anyone from following along. If you&amp;#8217;re not all that interested in understanding how everything works I guess that skipping the Innards of &lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt; dongles section should still provide a minimum working knowledge of &lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt; going forward. You can always refer back to this post if you need a more in depth understanding further along the&amp;nbsp;path&amp;#8230;&lt;/p&gt;
&lt;h1&gt;Analog Communications&amp;nbsp;101&lt;/h1&gt;
&lt;p&gt;Communication systems often involve transmitting a message &lt;span class="math"&gt;\(m(t)\)&lt;/span&gt; through a pass-band channel, i.e., a channel where only a limited range of frequencies can be used. A good example is comercial &lt;span class="caps"&gt;FM&lt;/span&gt; radio transmissions, usually restricted to a frequency band between 85 and 108 MHz which must accommodate multiple stations, each one being allocated a &amp;lt;200 kHz band. Given that the message we&amp;#8217;re interested in transmitting often has support in a different range of frequencies, as is the case of raw audio signals in the human hearing range ([20 Hz; 20 kHz]), the signal must first be shifted in frequency in order to satisfy the requirements of the particular channel of&amp;nbsp;communication.&lt;/p&gt;
&lt;p&gt;This is accomplished by modulation whereby one characteristic of a carrier wave (usually sinusoid like &lt;span class="math"&gt;\(A\cos(2\pi f_ct)\)&lt;/span&gt;) will be made to vary according to the &lt;em&gt;modulating signal&lt;/em&gt;: &lt;span class="math"&gt;\(m(t)\)&lt;/span&gt; (also called the message) producing a &lt;em&gt;modulated signal&lt;/em&gt;: &lt;span class="math"&gt;\(s(t)=B(t)\cos[2\pi f_ct + \theta (t)]\)&lt;/span&gt;. There are two main forms of analog&amp;nbsp;modulation:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Amplitude Modulation (&lt;span class="caps"&gt;AM&lt;/span&gt;)&lt;/strong&gt;: where the characteristic that is made to vary is the amplitude &lt;span class="math"&gt;\(B(t)\)&lt;/span&gt; of the&amp;nbsp;carrier;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Phase/Frequency Modulation (&lt;span class="caps"&gt;PM&lt;/span&gt;/&lt;span class="caps"&gt;FM&lt;/span&gt;)&lt;/strong&gt;: where the characteristic that varies is the phase &lt;span class="math"&gt;\(\theta (t)\)&lt;/span&gt; of the&amp;nbsp;carrier.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="Modulation" src="http://ajoo.blog/images/modulation.svg"&gt;&lt;/p&gt;
&lt;p&gt;We&amp;#8217;ll discuss these in the following sections as they help introduce a few points that are important later on but before we move on here&amp;#8217;s a useful glossary of terms commonly used in&amp;nbsp;telecommunications:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Baseband&lt;/strong&gt; (signal): Signal that has support in a narrow range of frequencies about 0&amp;nbsp;Hz;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Passband&lt;/strong&gt; (signal): Signal that has support in a narrow range of frequencies about a central frequency &lt;span class="math"&gt;\(f_c\)&lt;/span&gt;;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Bandwidth&lt;/strong&gt; (of a signal): some measure of the support of a signal in the frequency domain (has many different technical&amp;nbsp;definitions);&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;&lt;/h1&gt;
&lt;h2&gt;Amplitude&amp;nbsp;Modulation&lt;/h2&gt;
&lt;p&gt;The simplest form of modulation is double sideband amplitude modulation (&lt;span class="caps"&gt;DSB&lt;/span&gt;-&lt;span class="caps"&gt;AM&lt;/span&gt;). As the name indicates, this modulation uses the amplitude of the modulated signal to encode the message to be sent. This is achieved by simply multiplying (or in telecommunications&amp;#8217; lingo mixing) the message with a sinusoidal carrier&amp;nbsp;wave.&lt;/p&gt;
&lt;div class="math"&gt;$$s(t)=Am(t)\cos(2\pi f_ct)$$&lt;/div&gt;
&lt;p&gt;In the frequency domain this has the effect of convolving the Fourier transform &lt;span class="math"&gt;\(M(f)\)&lt;/span&gt; of &lt;span class="math"&gt;\(m(t)\)&lt;/span&gt; with that of a cosine&amp;nbsp;wave:&lt;/p&gt;
&lt;div class="math"&gt;$$\begin{eqnarray*}
S(f)&amp;amp; =&amp;amp; M(f)*\frac{A}{2}[\delta (f-f_c) + \delta (f+f_c)]\\\\
&amp;amp;=&amp;amp; \frac{A}{2}[M(f-f_c)+M(f+f_c)]
\end{eqnarray*}$$&lt;/div&gt;
&lt;p&gt;which effectively shifts the spectrum of &lt;span class="math"&gt;\(m\)&lt;/span&gt; to &lt;span class="math"&gt;\(f_c\)&lt;/span&gt;. If &lt;span class="math"&gt;\(m(t)\)&lt;/span&gt; is a baseband signal, this (up)converts it to a passband signal around &lt;span class="math"&gt;\(f_c\)&lt;/span&gt; so it can be transmitted through an appropriate bandpass&amp;nbsp;channel.&lt;/p&gt;
&lt;p&gt;&lt;img alt="AM modulation" src="http://ajoo.blog/images/AM_modulation.svg"&gt;&lt;/p&gt;
&lt;p&gt;Demodulating the signal can in theory be done by multiplying again by a sinusoid of the appropriate frequency. This second mixing will shift a copy of the original message back to f=0 and another to a frequency &lt;span class="math"&gt;\(f=2f_c\)&lt;/span&gt; which can be discarded by low-pass&amp;nbsp;filtering. &lt;/p&gt;
&lt;p&gt;&lt;img alt="AM demodulation" src="http://ajoo.blog/images/AM_demodulation.svg"&gt;&lt;/p&gt;
&lt;p&gt;On the receiver side however we don&amp;#8217;t know the original phase of the carrier, which we will denote &lt;span class="math"&gt;\(\phi\)&lt;/span&gt;, and therefore it&amp;#8217;s impossible to align it with the sinusoid generated locally at the receiver end. Introducing this initial phase our received signal can be written&amp;nbsp;as:&lt;/p&gt;
&lt;div class="math"&gt;$$\begin{eqnarray*}
s(t)&amp;amp; =&amp;amp; Am(t)\cos(2\pi f_ct+\phi)\\\\
&amp;amp; =&amp;amp; Am(t)[\cos(2\pi f_ct)\cos(\phi) - \sin(2\pi f_ct)\sin(\phi)]
\end{eqnarray*}$$&lt;/div&gt;
&lt;p&gt;The result of our naive demodulation scheme is&amp;nbsp;then:&lt;/p&gt;
&lt;div class="math"&gt;$$s(t)\cos(2\pi f_ct) = \frac{A}{2}m(t)\{[1+\cos(4\pi f_ct)]\cos(\phi)-\sin(4\pi f_ct)\sin(\phi)\}$$&lt;/div&gt;
&lt;p&gt;This is effectively &lt;span class="math"&gt;\(\frac{A}{2}m(t)\cos(\phi)\)&lt;/span&gt; + a couple terms at frequency &lt;span class="math"&gt;\(2f_c\)&lt;/span&gt; which are the result of this second mixing. Low pass filtering this signal to get rid of these higher frequency components then yields the desired result with one caveat: the constant factor &lt;span class="math"&gt;\(\cos(\phi)\)&lt;/span&gt; which in the worst case is 0 when the two waves are in quadrature with each&amp;nbsp;other.&lt;/p&gt;
&lt;p&gt;One way to get around this scheme&amp;#8217;s limitation is mixing the received signal not only with a locally generated sinusoidal wave &lt;span class="math"&gt;\(\cos(2\pi f_ct)\)&lt;/span&gt; but also with a second sinusoid shifted 90Âº in phase: &lt;span class="math"&gt;\(-\sin(2\pi f_ct)\)&lt;/span&gt;. After low pass-filtering this results&amp;nbsp;in:
&lt;/p&gt;
&lt;div class="math"&gt;$$s_b(t)\doteq h_{LP}(t)*s(t)\begin{bmatrix}\cos(2\pi f_ct) \\-\sin(2\pi f_ct) \end{bmatrix}=\frac{A}{2}m(t)\begin{bmatrix}\cos(\phi) \\ \sin(\phi) \end{bmatrix}$$&lt;/div&gt;
&lt;p&gt;
And since the sine and cosine can&amp;#8217;t both be 0 we can always recover our message. An elegant way of doing that is by taking the Euclidean norm of the vector which gets rid of the factor depending on &lt;span class="math"&gt;\(\phi\)&lt;/span&gt; yielding &lt;span class="math"&gt;\(Am(t)/2\)&lt;/span&gt;. We can also figure out the original carrier wave&amp;#8217;s phase from the arctangent of the two&amp;nbsp;components.&lt;/p&gt;
&lt;p&gt;&lt;img alt="AM demodulation diagram" src="http://ajoo.blog/images/AM_demodulation_diagram_cb.svg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;It is important to note however that in &lt;strong&gt;standard &lt;span class="caps"&gt;AM&lt;/span&gt;&lt;/strong&gt; the message must first be shifted by a constant C such that &lt;span class="math"&gt;\(m(t)+C\geq 0\)&lt;/span&gt;. This means higher power consumption since we&amp;#8217;re &amp;#8220;wasting&amp;#8221; energy transmitting the carrier together with the message but on the other hand the receiver has access to the original carrier and certain simpler demodulation schemes such as envelope detection are&amp;nbsp;available.&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;Complex Baseband&amp;nbsp;Representation&lt;/h2&gt;
&lt;p&gt;What we&amp;#8217;ve done in order to demodulate &lt;span class="caps"&gt;AM&lt;/span&gt; is essentially downconvert the modulated signal back to baseband. We realized however that mixing with a single sinusoid does not capture all the information present in the original passband signal but that two not in phase sinusoids must be used. This can be interpreted making use of the fact that Fourier transforms of real signals are in the general case complex functions of frequency satisfying &lt;span class="math"&gt;\(S(f)=S^*(-f)\)&lt;/span&gt;. Mixing a passband signal with a cosine wave will shift the spectrum but kill any imaginary component since the positive and negative frequency contributions will cancel each other out. The same is true for sine waves and real&amp;nbsp;components. &lt;/p&gt;
&lt;p&gt;One way to retain full information is then to simply multiply the passband signal with a complex sinusoid &lt;span class="math"&gt;\(e^{-j2\pi f_ct}\)&lt;/span&gt; which  will shift only the positive part of the spectrum back to f=0 avoiding the whole&amp;nbsp;issue.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Complex Baseband Spectrum" src="http://ajoo.blog/images/CB_spectrum.svg"&gt;&lt;/p&gt;
&lt;p&gt;That&amp;#8217;s exactly what we&amp;#8217;ve done with our modified demodulation except we disguised it by writing it as a real 2-vector&amp;nbsp;instead:
&lt;/p&gt;
&lt;div class="math"&gt;$$e^{-j2\pi f_ct}=\cos(2\pi f_ct)-j\sin(2\pi f_ct)\rightarrow \begin{bmatrix}\cos(2\pi f_ct) \\-\sin(2\pi f_ct) \end{bmatrix}$$&lt;/div&gt;
&lt;p&gt;In fact, given any passband signal &lt;span class="math"&gt;\(s(t)\)&lt;/span&gt;, we can write it in the&amp;nbsp;form:
&lt;/p&gt;
&lt;div class="math"&gt;$$s(t) = 2s_I(t)\cos(2\pi f_ct)-2s_Q(t)\sin(2\pi f_ct)$$&lt;/div&gt;
&lt;p&gt;
which implicitly defines its &lt;strong&gt;I&lt;/strong&gt;n phase (&lt;span class="math"&gt;\(s_I(t)\)&lt;/span&gt;) and &lt;strong&gt;Q&lt;/strong&gt;uadrature (&lt;span class="math"&gt;\(s_Q(t)\)&lt;/span&gt;) components (I/Q). It&amp;#8217;s &lt;strong&gt;complex baseband representation&lt;/strong&gt; is then defined&amp;nbsp;as:
&lt;/p&gt;
&lt;div class="math"&gt;$$s_b(t) \doteq s_I(t)+js_Q(t)$$&lt;/div&gt;
&lt;p&gt;This is a very useful representation of a pass-band signal since it contains the same information as the original signal but is band-limited by a much lower frequency. If &lt;span class="math"&gt;\(s(t)\)&lt;/span&gt; has a bandwidth of W around a frequency &lt;span class="math"&gt;\(f_c\)&lt;/span&gt;, then it&amp;#8217;s band-limited by &lt;span class="math"&gt;\(f_c+W/2\)&lt;/span&gt; and therefore, by Nyquist&amp;#8217;s theorem, must be sampled at least at &lt;span class="math"&gt;\(f_s \geq 2f_c+W\)&lt;/span&gt;. By contrast, &lt;span class="math"&gt;\(s_b(t)\)&lt;/span&gt; is band-limited by &lt;span class="math"&gt;\(W/2\)&lt;/span&gt; and can be sampled and digitally processed at the (usually) much more amenable &lt;span class="math"&gt;\(f_s \geq W\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Complex Baseband" src="http://ajoo.blog/images/complex_baseband_real_imag.svg"&gt;&lt;/p&gt;
&lt;p&gt;Alternative ways to write &lt;span class="math"&gt;\(s(t)\)&lt;/span&gt; as a function of &lt;span class="math"&gt;\(s_b(t)\)&lt;/span&gt;&amp;nbsp;are:
&lt;/p&gt;
&lt;div class="math"&gt;$$\begin{eqnarray*}
s(t)&amp;amp; =&amp;amp; \mathrm{Re}[2s_b(t)e^{j2\pi f_ct}]\\\\
&amp;amp;=&amp;amp; 2\mid s_b(t)\mid\cos[2\pi f_ct+\angle s_b(t)]
\end{eqnarray*}$$&lt;/div&gt;
&lt;p&gt;The last expression makes obvious what we already saw in the previous section about demodulating an &lt;span class="caps"&gt;AM&lt;/span&gt; signal given it&amp;#8217;s complex baseband representation. That it amounts to taking it&amp;#8217;s complex norm: &lt;span class="math"&gt;\(\mid s_b(t)\mid\)&lt;/span&gt; (also called the envelope). Likewise, it&amp;#8217;s phase &lt;span class="math"&gt;\(\angle s_b(t)\)&lt;/span&gt; gives us all the information necessary to demodulate any angle based&amp;nbsp;modulation.&lt;/p&gt;
&lt;p&gt;We can now represent the same diagram depicting how to obtain the complex baseband representation and reconstruct the original passband signal but in complex&amp;nbsp;notation:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Complex Baseband" src="http://ajoo.blog/images/complex_baseband_complex.svg"&gt;&lt;/p&gt;
&lt;h2&gt;Frequency&amp;nbsp;Modulation&lt;/h2&gt;
&lt;p&gt;In frequency modulation the message is encoded in the instantaneous frequency of the carrier&amp;nbsp;wave:&lt;/p&gt;
&lt;div class="math"&gt;$$\begin{eqnarray*}
s(t) &amp;amp;= &amp;amp;A\cos\left[2\pi \int_{-\infty}^{t}f_c+f_\Delta m(\tau)d\tau\right]\\\\
&amp;amp;= &amp;amp;A\cos\left[2\pi f_ct + 2\pi f_\Delta\int_{-\infty}^{t}m(\tau)d\tau\right]
\end{eqnarray*}$$&lt;/div&gt;
&lt;p&gt;Comparing the above expression with the last formula giving the passband signal from it&amp;#8217;s complex baseband representation we find that for a frequency modulated signal we&amp;nbsp;have:&lt;/p&gt;
&lt;div class="math"&gt;$$\mid s_b(t)\mid = \frac{A}{2},\quad\angle s_b(t) = 2\pi f_\Delta\int_{-\infty}^{t}m(\tau)d\tau$$&lt;/div&gt;
&lt;p&gt;We can thus easily find a scheme to demodulate &lt;span class="caps"&gt;FM&lt;/span&gt; signals by converting to complex baseband and differentiating its phase in order to find the instantaneous&amp;nbsp;frequency:&lt;/p&gt;
&lt;div class="math"&gt;$$\frac{\text{d}\angle s_b(t)}{\text{d}t} = 2\pi f_\Delta m(t)$$&lt;/div&gt;
&lt;p&gt;&lt;img alt="FM Demodulation Diagram" src="http://ajoo.blog/images/FM_demodulation_diagram.svg"&gt;&lt;/p&gt;
&lt;h1&gt;Software Defined&amp;nbsp;Radio&lt;/h1&gt;
&lt;p&gt;Many forms of radio communication systems were designed with analog technology in mind. Software Defined Radio (&lt;strong&gt;&lt;span class="caps"&gt;SDR&lt;/span&gt;&lt;/strong&gt;) is a communication system where part of the traditionally analog signal processing, accomplished by means of analog electronic circuits is replaced by digital signal processing (&lt;span class="caps"&gt;DSP&lt;/span&gt;, accomplished my means of analog to digital conversion/digital to analog conversion (&lt;span class="caps"&gt;ADC&lt;/span&gt;/&lt;span class="caps"&gt;DAC&lt;/span&gt;) and any form of computers or embedded system running &lt;span class="caps"&gt;DSP&lt;/span&gt;&amp;nbsp;software.&lt;/p&gt;
&lt;p&gt;By replacing hardware components with software, through inserting an &lt;span class="caps"&gt;ADC&lt;/span&gt;/&lt;span class="caps"&gt;DAC&lt;/span&gt; as far upstream the signal flow as possible and processing the digital signal instead, very flexible and general purpose systems can be realized since software is much easier to change than hardware components. Ideally, one would place an &lt;span class="caps"&gt;ADC&lt;/span&gt; or &lt;span class="caps"&gt;DAC&lt;/span&gt; directly at the antenna for maximum flexibility  but this is not practical and &lt;span class="caps"&gt;SDR&lt;/span&gt; systems typically include a flexible &lt;a href="https://en.wikipedia.org/wiki/RF_front_end"&gt;radio frequency (&lt;span class="caps"&gt;RF&lt;/span&gt;) front-end&lt;/a&gt; before sampling as in the conceptual diagram below depicting the typical &lt;span class="caps"&gt;SDR&lt;/span&gt; system based on the one that can be found on &lt;a href="https://en.wikipedia.org/wiki/Software-defined_radio"&gt;Wikipedia&amp;#8217;s &lt;span class="caps"&gt;SDR&lt;/span&gt; Page&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Conceptual SDR system" src="http://ajoo.blog/images/SDR_system.svg"&gt;&lt;/p&gt;
&lt;p&gt;Note that the term Software Defined Radio denotes the whole communication system including the antenna, any specialized hardware and the computer/embedded system running the &lt;span class="caps"&gt;DSP&lt;/span&gt;. In the following however we&amp;#8217;ll (ab)use it by equating it with the hardware that is used to deliver the digital samples to a personal computer since that is the use case we&amp;#8217;re interested&amp;nbsp;in.&lt;/p&gt;
&lt;h1&gt;A Cheap &lt;span class="caps"&gt;SDR&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;There are many general purpose commercially available SDRs, both receiver only and receiver/transceiver, but they&amp;#8217;re rather expensive in general (&amp;gt;â¬100 for &lt;span class="caps"&gt;RX&lt;/span&gt; and &amp;gt;â¬300 for &lt;span class="caps"&gt;RX&lt;/span&gt;/&lt;span class="caps"&gt;TX&lt;/span&gt;). This is where &lt;span class="caps"&gt;DVB&lt;/span&gt;-T &lt;span class="caps"&gt;TV&lt;/span&gt; tuner &lt;span class="caps"&gt;USB&lt;/span&gt; dongles based on the &lt;span class="caps"&gt;RTL2832U&lt;/span&gt; chipset come into play. As the name indicates, these cheap dongles (â¬10~â¬20) were meant for receiving &lt;span class="caps"&gt;DVB&lt;/span&gt;-T &lt;span class="caps"&gt;TV&lt;/span&gt; but hacked drivers from &lt;a href="http://sdr.osmocom.org/trac/wiki/rtl-sdr"&gt;Osmocom&lt;/a&gt; are able to turn them into wideband receiver only SDRs. This cheap &lt;span class="caps"&gt;SDR&lt;/span&gt; is therefore typically known as the &lt;strong&gt;&lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt;&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img alt="RTL dongles" src="https://ajoo.blog/images/RTL_dongles.jpg"&gt;&lt;/p&gt;
&lt;p&gt;Here you can see the two dongles I own. The one on top looks like a generic &lt;span class="caps"&gt;DVB&lt;/span&gt;-T &lt;span class="caps"&gt;USB&lt;/span&gt; dongle but it was tuned by NooElec for use as a &lt;span class="caps"&gt;SDR&lt;/span&gt;. You can see in the picture the remote that comes with it for its original intended use as a &lt;span class="caps"&gt;TV&lt;/span&gt; tuner. It has a standard &lt;span class="caps"&gt;MCX&lt;/span&gt; antenna connector and comes with a small whip&amp;nbsp;antenna.&lt;/p&gt;
&lt;p&gt;The dongle that you see at the bottom is the one sold by the &lt;a href="http://www.rtl-sdr.com/buy-rtl-sdr-dvb-t-dongles/"&gt;&lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt; blog&lt;/a&gt;. It comes with several improvements over the generic dongles for use as a &lt;span class="caps"&gt;SDR&lt;/span&gt;. You can read all about these in the the webpage linked. For my intended use of capturing &lt;span class="caps"&gt;GPS&lt;/span&gt; signals I was mostly interested in the software enabled bias-T in order to power an active &lt;span class="caps"&gt;GPS&lt;/span&gt; antenna, the &lt;span class="caps"&gt;SMA&lt;/span&gt; antenna connector and of course the 1 &lt;span class="caps"&gt;PPM&lt;/span&gt; temperature controlled oscillator for more accurate tuning (the passive cooling is a nice plus too since these units tend to run hot when tuning to frequencies &amp;gt; 1500&amp;nbsp;MHz).&lt;/p&gt;
&lt;h2&gt;The innards of &lt;span class="caps"&gt;RTL2832U&lt;/span&gt; based &lt;span class="caps"&gt;DVB&lt;/span&gt;-T &lt;span class="caps"&gt;TV&lt;/span&gt; &lt;span class="caps"&gt;USB&lt;/span&gt;&amp;nbsp;dongles&lt;/h2&gt;
&lt;p&gt;The overall architecture of &lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt; dongles is based on a &lt;a href="https://en.wikipedia.org/wiki/Superheterodyne_receiver"&gt;superheterodyne receiver&lt;/a&gt; which is a popular design for receivers that must be able to process signals at a wide range of user-selected frequencies, isolating them from other signals and amplifying them. Examples are many conventional &lt;span class="caps"&gt;AM&lt;/span&gt;/&lt;span class="caps"&gt;FM&lt;/span&gt; radio receivers where the user selects a channel by tuning the radio to it&amp;#8217;s carrier wave&amp;nbsp;frequency.&lt;/p&gt;
&lt;p&gt;A selective enough filter must be applied to the signal coming from the antenna in order to filter out other signals and noise outside the band of interest before demodulation. For the purpose described above it must also have a tunable center-frequency which makes its practical implementation troublesome. Superheterodyne architectures solve this by downconverting first to an &lt;strong&gt;intermediate frequency&lt;/strong&gt; (&lt;span class="caps"&gt;IF&lt;/span&gt;) in which more rigorous filtering and amplification stages can be applied now that the signal is at a fixed pre-specified frequency (see the figure below for a typical&amp;nbsp;setup).&lt;/p&gt;
&lt;p&gt;&lt;img alt="Superheterodyne Receiver" src="http://ajoo.blog/images/superhet.svg"&gt;&lt;/p&gt;
&lt;p&gt;This downconversion is achieved by mixing with a sinusoidal wave of the appropriate frequency generated by a local oscillator (&lt;span class="caps"&gt;LO&lt;/span&gt;). When the user selects a frequency &lt;span class="math"&gt;\(f_c\)&lt;/span&gt; to tune to, the &lt;span class="caps"&gt;LO&lt;/span&gt; generates a sine wave at either &lt;span class="math"&gt;\(f_{LO} = f_c-f_{IF}\)&lt;/span&gt; (low-side injection) or &lt;span class="math"&gt;\(f_{LO} = f_c+f_{IF}\)&lt;/span&gt; (high-side injection, note that when using this frequency the spectrum of the resulting signal will be inverted in frequency). A byproduct of this mixing is that both &lt;span class="math"&gt;\(f_c\)&lt;/span&gt; and &lt;span class="math"&gt;\(f_c\mp 2f_{IF}\)&lt;/span&gt; (for low/high side injection respectively) get mixed into the intermediate frequency. The first is the frequency of interest and the other is the so called &lt;strong&gt;image frequency&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="IF Spectrum" src="http://ajoo.blog/images/IF_spectrum.svg"&gt;&lt;/p&gt;
&lt;p&gt;An initial radio frequency (&lt;span class="caps"&gt;RF&lt;/span&gt;) filtering stage is therefore useful in order to filter out any signal or noise at this image frequency. This &lt;span class="caps"&gt;RF&lt;/span&gt; filter often has a variable center frequency whose tuning is shared with the &lt;span class="caps"&gt;LO&lt;/span&gt;. Another common component of the &lt;span class="caps"&gt;RF&lt;/span&gt; section of the receiver is an amplifier, often called a low noise amplifier (&lt;span class="caps"&gt;LNA&lt;/span&gt;).&lt;/p&gt;
&lt;p&gt;While traditionally the intermediate frequency signal processing section was analog, lately, due to the ubiquity of integrated circuits and the availability of micro-processors in many devices (such as cell-phones) the trend has been to handle some of these tasks digitally. In this case, superheterodyne architectures are useful as they downconvert a passband signal that is too impractical to sample (due to their high frequency requiring very high sample rates) into a lower frequency passband signal that is more manageable to sample without&amp;nbsp;aliasing.&lt;/p&gt;
&lt;p&gt;In the &lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt; dongles the signal is sampled at a low intermediate frequency after an analog filtering and amplification stage and further processed digitally. &lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt; dongles contain 2 important integrated circuits (ICs) which implement the different functions of the superheterodyne&amp;nbsp;receiver:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Tuner&lt;/strong&gt;: The &lt;span class="caps"&gt;RF&lt;/span&gt; front-end which implements the analog signal processing part of the receiver and is responsible for the downconversion into the intermediate&amp;nbsp;frequency;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;The &lt;span class="caps"&gt;RTL2832U&lt;/span&gt;&lt;/strong&gt;: Samples the signal and performs additional digital signal processing tasks such as decimation. Also handles &lt;span class="caps"&gt;USB&lt;/span&gt;&amp;nbsp;control.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class="figure"&gt;
	&lt;img src="https://ajoo.blog/external_images/nesdr_mini_pcb_annotated.jpg" width="500" alt="NooElec RTL-SDR PCB"&gt;
	&lt;p class="caption"&gt;NooElec &lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt; dongle opened up. &lt;a href=http://www.nooelec.com/store/sdr/sdr-receivers/nesdr-mini-rtl2832-r820t.html&gt;Image&amp;nbsp;source&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The following sections will go into details about the function of each of these important components. Information from these sections is gathered from multiple sources including the &lt;a href="https://github.com/steve-m/librtlsdr"&gt;Osmocom driver&amp;#8217;s source code&lt;/a&gt;. &lt;a href="http://superkuh.com/rtlsdr.html"&gt;Superkuh&amp;#8217;s website&lt;/a&gt; deserves a special mention as it is a veritable treasure cove for anything &lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt;&amp;nbsp;related.&lt;/p&gt;
&lt;h3&gt;Tuner&lt;/h3&gt;
&lt;p&gt;There are two main families of tuner chips of interest for &lt;span class="caps"&gt;SDR&lt;/span&gt; applications, the now discontinued Elonics E4000 and the Raphael Micro &lt;span class="caps"&gt;R820T&lt;/span&gt;/&lt;span class="caps"&gt;R820T2&lt;/span&gt; radio tuner which will be the focus of this discussion. The differences between the T and the T2 are small, essentially amounting to slightly better sensitivity&lt;a href="http://superkuh.com/rtlsdr.html"&gt;Â¹&lt;/a&gt; for practical&amp;nbsp;purposes.&lt;/p&gt;
&lt;p&gt;The &lt;a href="http://superkuh.com/gnuradio/R820T_datasheet-Non_R-20111130_unlocked.pdf"&gt;datasheet&lt;/a&gt; for the &lt;span class="caps"&gt;R820T&lt;/span&gt; was leaked online so a lot is known about the inner workings of this chip. A &lt;a href="http://superkuh.com/R820T2_Register_Description.pdf"&gt;register description&lt;/a&gt; for the &lt;span class="caps"&gt;R820T2&lt;/span&gt; is also available which details the parameters of the tuner that can be set from outside. A high level simplified diagram based on the one found in the datasheet is depicted&amp;nbsp;next:&lt;/p&gt;
&lt;p&gt;&lt;img alt="R820T Diagram" src="http://ajoo.blog/images/R820T.svg"&gt; &lt;/p&gt;
&lt;p&gt;The signal coming from the antenna connector first goes through a low noise amplifier (&lt;span class="caps"&gt;LNA&lt;/span&gt;) and is then filtered by a bandpass filter and an image rejection filter. According to the datasheet, the image rejection is 65&amp;nbsp;dBc.&lt;/p&gt;
&lt;p&gt;A fractional &lt;span class="caps"&gt;PLL&lt;/span&gt; based frequency synthesizer generates the &lt;span class="caps"&gt;LO&lt;/span&gt; that is mixed with this filtered signal in order to downconvert it to a low intermediate frequency. The user controls the local oscillator&amp;#8217;s frequency directly through the parameters of the frequency synthesizer. This indirectly sets the &lt;span class="caps"&gt;IF&lt;/span&gt; frequency and whether low or high-side injection is used. 3.57 MHz and 4.57 MHz are typical values for the &lt;span class="caps"&gt;IF&lt;/span&gt; of &lt;span class="caps"&gt;R820T&lt;/span&gt; dongles&lt;a href="http://superkuh.com/rtlsdr.html"&gt;Â¹&lt;/a&gt; but it&amp;#8217;s essentially up to the driver implementation to choose what values to use (subject to the limits imposed by the parameters of the synthesizer and the &lt;span class="caps"&gt;IF&lt;/span&gt;&amp;nbsp;filter). &lt;/p&gt;
&lt;p&gt;The frequency range that the &lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt; is able to tune to is determined by the range of frequencies that the frequency synthesizer inside the chip can generate. The &lt;span class="caps"&gt;R820T&lt;/span&gt;âs official range found in the data sheet is [42; 1002] MHz with a tuning resolution of 1 Hz but the generally agreed upon real range is [24; 1766] MHz&lt;a href="http://superkuh.com/rtlsdr.html"&gt;Â¹&lt;/a&gt; as determined by the &lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt; community.
In fact, using an experimental set of &lt;a href="https://github.com/mutability/rtl-sdr/"&gt;drivers&lt;/a&gt; this frequency range has been extended as far as [13; 1864] MHz with the upper limit having some variability depending on the dongle&amp;nbsp;used.&lt;/p&gt;
&lt;p&gt;Finally once at the intermediate frequency the signal is again filtered and goes through a variable gain amplifier (&lt;span class="caps"&gt;VGA&lt;/span&gt;). The &lt;span class="caps"&gt;IF&lt;/span&gt; filter is usually more selective than the &lt;span class="caps"&gt;RF&lt;/span&gt; since that is the point of superheterodyne architectures. In the case of the &lt;span class="caps"&gt;R820T&lt;/span&gt; it is composed of a low-pass filter and a high-pass one that can be configured to have a bandwidth as low as 300 kHz&lt;a href="http://lists.osmocom.org/pipermail/osmocom-sdr/2015-February/000019.html"&gt;Â²&lt;/a&gt;. Its &amp;#8220;standard values&amp;#8221; however are either 6, 7 or 8 MHz since these are the bandwidths used by &lt;span class="caps"&gt;DVB&lt;/span&gt;-T&amp;nbsp;signals. &lt;/p&gt;
&lt;p&gt;There are overall 3 gains in the tuner that can be controlled via external configuration: the &lt;span class="caps"&gt;LNA&lt;/span&gt;, the mixer and the &lt;span class="caps"&gt;VGA&lt;/span&gt;. These gains can be set manually although their precise values are absent from the datasheet. They can also be set automatically via automatic gain control (&lt;span class="caps"&gt;AGC&lt;/span&gt;) in order to optimize the signal to noise ratio (&lt;span class="caps"&gt;SNR&lt;/span&gt;). The &lt;span class="caps"&gt;LNA&lt;/span&gt; and mixer have a power detector at their outputs which is used to control their respective gains for this purpose. The &lt;span class="caps"&gt;VGA&lt;/span&gt; &lt;span class="caps"&gt;AGC&lt;/span&gt; is actually controlled via an analog input port to the tuner which is connected to a power detector in the &lt;span class="caps"&gt;RTL2832U&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;A note on the E4000 chips is that these use a 0 Hz &lt;span class="caps"&gt;IF&lt;/span&gt; so in effect they&amp;#8217;re not implementing superheterodyne receivers. This has a notable consequence of producing a &lt;span class="caps"&gt;DC&lt;/span&gt; spike at 0&amp;nbsp;Hz.&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class="caps"&gt;RTL2832U&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;This is the &lt;span class="caps"&gt;IC&lt;/span&gt; that gives the name to the &lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt; dongle. Unlike the tuner,  datasheets are not freely available online (you&amp;#8217;ll need to sign an &lt;span class="caps"&gt;NDA&lt;/span&gt; to obtain one). A lot of what is known about the inner workings of this chip has therefore been figured out by the &lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt; community through reverse&amp;nbsp;engineering. &lt;/p&gt;
&lt;p&gt;Realtek&amp;#8217;s &lt;a href="http://web.archive.org/web/20161012161902/http://www.realtek.com.tw/products/productsView.aspx?Langid=1&amp;amp;PFid=35&amp;amp;Level=4&amp;amp;Conn=3&amp;amp;ProdID=257"&gt;&lt;span class="caps"&gt;RTL2832U&lt;/span&gt; description&lt;/a&gt; states that the chip is meant as a high-performance &lt;span class="caps"&gt;DVB&lt;/span&gt;-T demodulator (with additional support for &lt;span class="caps"&gt;FM&lt;/span&gt; and &lt;span class="caps"&gt;DAB&lt;/span&gt; radio). As such it includes an &lt;span class="caps"&gt;ADC&lt;/span&gt; to sample the &lt;span class="caps"&gt;IF&lt;/span&gt; signal coming from an appropriate tuner, all the specialized &lt;span class="caps"&gt;DSP&lt;/span&gt; required to demodulate &lt;span class="caps"&gt;DVB&lt;/span&gt;-T and a &lt;span class="caps"&gt;USB&lt;/span&gt; controller supporting a &lt;span class="caps"&gt;USB&lt;/span&gt; 2.0 interface. Usage as an &lt;span class="caps"&gt;SDR&lt;/span&gt; takes advantage of a &amp;#8220;debug&amp;#8221; mode in the chip to deliver the digital complex baseband representation samples directly through &lt;span class="caps"&gt;USB&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;The following high-level diagram represents my best understanding of the functions the &lt;span class="caps"&gt;RTL2832U&lt;/span&gt; is performing when using a non-zero &lt;span class="caps"&gt;IF&lt;/span&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img alt="RTL2832U Diagram" src="http://ajoo.blog/images/RTL2832U.svg"&gt;&lt;/p&gt;
&lt;p&gt;Initially, the signal coming out of the tuner is sampled by an 8-bit &lt;span class="caps"&gt;ADC&lt;/span&gt; running at 28.8 MHz. No significant aliasing should occur for the low &lt;span class="caps"&gt;IF&lt;/span&gt; values supported if the &lt;span class="caps"&gt;IF&lt;/span&gt; filter is selective enough to kill any strong signals outside its&amp;nbsp;bandwidth.&lt;/p&gt;
&lt;p&gt;A &lt;a href="https://en.wikipedia.org/wiki/Digital_down_converter"&gt;digital downconverter&lt;/a&gt; (&lt;span class="caps"&gt;DDC&lt;/span&gt;) is then responsible for downconverting the digital signal to complex baseband. The process of obtaining the complex baseband representation is similar to the continuous-time case: mixing with a complex sinusoid will circularly shift the spectrum from &lt;span class="caps"&gt;IF&lt;/span&gt; down to baseband. The signal can then be low pass-filtered and downsampled to get rid of the unnecessary part of the spectrum that was shifted to higher frequencies since the signal of interest is now band-limited by a lower frequency. External configuration parameters inform the &lt;span class="caps"&gt;DDC&lt;/span&gt; of the &lt;span class="caps"&gt;IF&lt;/span&gt; frequency and whether the spectrum is inverted (i.e., if the tuner is high-side&amp;nbsp;injecting).&lt;/p&gt;
&lt;p&gt;Finally decimation (using a &lt;span class="caps"&gt;FIR&lt;/span&gt; low pass filter and downsampling) is applied in order to reduce the sample rate of the signal to a value in the range [225001; 300000] Hz âª [900001; 3200000] Hz. 2.56 MHz is however the generally agreed upon highest safe sample rate where no samples will be dropped by the chip (they may still be dropped by the &lt;span class="caps"&gt;USB&lt;/span&gt;). This decimation is what usually sets the upper limit on the bandwidth of the sampled signal (unless the &lt;span class="caps"&gt;IF&lt;/span&gt; filter bandwidth is specifically chosen as lower than the Nyquist frequency for the sample&amp;nbsp;rate).&lt;/p&gt;
&lt;p&gt;The I and Q complex baseband samples are then delivered through &lt;span class="caps"&gt;USB&lt;/span&gt; as interleaved 8-bit unsigned&amp;nbsp;integers.&lt;/p&gt;
&lt;h2&gt;A High Level Behavioral&amp;nbsp;Model&lt;/h2&gt;
&lt;p&gt;It is sometimes useful to have a simplified picture in mind of the &lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt;&amp;#8217;s internals. This picture, while not perfectly accurate captures the essential behavior of the hardware while hiding some of the complexity. One such behavioral level model of the &lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt; is presented next, based upon
&lt;a href="http://www.eas.uccs.edu/~mwickert/ece4670/lecture_notes/Lab6.pdf"&gt;Lab 6&lt;/a&gt; from &lt;a href="http://web.stanford.edu/class/ee179/"&gt;Stanford&amp;#8217;s Analog and Digital Communication Systems 2014 course&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Behavioral Model" src="http://ajoo.blog/images/behavioural_model.svg"&gt; &lt;/p&gt;
&lt;p&gt;In its essence, the &lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt; provides us a digital complex baseband representation of the signal at whatever frequency band we tune to. Doing away with the added complexity of the superheterodyne architecture, the &lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt;&amp;#8217;s functioning can be boiled down&amp;nbsp;to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Amplification;&lt;/li&gt;
&lt;li&gt;Finding the complex baseband representation through mixing with a complex sinusoid and low-pass&amp;nbsp;filtering;&lt;/li&gt;
&lt;li&gt;Sampling.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These are the essential steps represented in the diagram. The three essential parameters we are able to vary&amp;nbsp;are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The gain values (and possible &lt;span class="caps"&gt;AGC&lt;/span&gt;);&lt;/li&gt;
&lt;li&gt;The center frequency we&amp;#8217;re tuning&amp;nbsp;to;&lt;/li&gt;
&lt;li&gt;The sample rate which can go up to ~2.56 MHz without dropping&amp;nbsp;samples;&lt;/li&gt;
&lt;li&gt;The bandwidth of the filter which can be chosen anywhere from 300 kHz (making use of the &lt;span class="caps"&gt;IF&lt;/span&gt; filter inside the tuner) up to roughly the Nyquist frequency of the chosen sample rate (where the limiting factor will usually be the decimation filter inside the &lt;span class="caps"&gt;RTL2832U&lt;/span&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;&lt;/h1&gt;
&lt;h1&gt;Up&amp;nbsp;Next&lt;/h1&gt;
&lt;p&gt;The second part of this introduction will introduce the basic software that most &lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt; enthusiasts stick to and use it to demodulate &lt;span class="caps"&gt;FM&lt;/span&gt; signals. Stay&amp;nbsp;tuned!&lt;/p&gt;
&lt;h1&gt;Useful&amp;nbsp;Links:&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.rtl-sdr.com/"&gt;rtl-sdr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://sdr.osmocom.org/trac/wiki/rtl-sdr"&gt;Osmocom rtl-sdr&amp;nbsp;wiki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.reddit.com/r/RTLSDR/"&gt;&lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt; subreddit&lt;/a&gt; A subreddit dedicated to &lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt;. Make sure to check their wiki which is filled with useful&amp;nbsp;information.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://rtlsdr.org/"&gt;rtlsdr Community&amp;nbsp;Wiki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://superkuh.com/rtlsdr.html"&gt;superkuh&amp;#8217;s website&lt;/a&gt; An absolute bible when it comes to the internals of &lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt; &lt;span class="caps"&gt;USB&lt;/span&gt; dongles. Tons of useful information, links to datasheets, schematics,&amp;nbsp;etc&amp;#8230; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.eas.uccs.edu/~mwickert/ece4670/"&gt;University of Colorado&amp;#8217;s Communications Lab&lt;/a&gt; Make sure to check out their lab assignments, particularly Lab 6 which this blog post draws inspiration&amp;nbsp;from;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://web.stanford.edu/class/ee179/"&gt;Stanford&amp;#8217;s Analog and Digital Communication Systems 2014 course&lt;/a&gt; Again, make sure to check out the lab assignments for lots of &lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt;&amp;nbsp;material;&lt;/li&gt;
&lt;/ul&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="RTL-SDR"></category><category term="DSP"></category></entry><entry><title>Software Defined GNSS</title><link href="http://ajoo.blog/software-defined-gnss.html" rel="alternate"></link><published>2016-12-18T12:00:00+00:00</published><updated>2017-01-09T13:00:00+00:00</updated><author><name>Ajoo</name></author><id>tag:ajoo.blog,2016-12-18:/software-defined-gnss.html</id><summary type="html">&lt;p&gt;A short introduction to my Software Defined &lt;span class="caps"&gt;GNSS&lt;/span&gt;&amp;nbsp;project&lt;/p&gt;</summary><content type="html">&lt;p&gt;When I first heard about Software Defined Radios (&lt;span class="caps"&gt;SDR&lt;/span&gt;) I was instantly hooked. The ability to probe the electromagnetic spectrum around me and decode the ubiquitous signals being transmitted seemed to open a door to new and interesting experiments. I loved Digital Signal Processing (&lt;span class="caps"&gt;DSP&lt;/span&gt;) when I was in college (still do) and this was exactly what I was looking for to put it in practice. I started looking for a project to sink my teeth in that went besides using established software and a cheap &lt;span class="caps"&gt;SDR&lt;/span&gt; to decode well known &lt;span class="caps"&gt;AM&lt;/span&gt;, &lt;span class="caps"&gt;FM&lt;/span&gt; and &lt;span class="caps"&gt;ADS&lt;/span&gt;-B&amp;nbsp;signals.&lt;/p&gt;
&lt;p&gt;Since my main background is in Guidance, Navigation and Control (and I&amp;#8217;m a person walking this Earth in 2016) I&amp;#8217;ve made use of &lt;span class="caps"&gt;GPS&lt;/span&gt; before and I&amp;#8217;m familiar to some extent with its inner workings from a course in Global Navigation Satellite Systems (&lt;span class="caps"&gt;GNSS&lt;/span&gt;) I attended in college. I&amp;#8217;ve always felt however that my knowledge of this system is not as deep as I want it to be, particularly regarding the receiver side of things. I think it&amp;#8217;s therefore appropriate that my first foray into the exciting world of &lt;span class="caps"&gt;SDR&lt;/span&gt; be the implementation of a &lt;span class="caps"&gt;GPS&lt;/span&gt;/&lt;span class="caps"&gt;GNSS&lt;/span&gt; receiver in software. I intend to take this as far as I can, from measuring &lt;span class="caps"&gt;GPS&lt;/span&gt; L1 signals to computing a full navigation solution of position and velocity, learning as much as I can along the way and sharing it with any interested&amp;nbsp;readers.&lt;/p&gt;
&lt;p&gt;My particular goals for this project are&amp;nbsp;therefore:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;To put my knowledge of &lt;span class="caps"&gt;GNSS&lt;/span&gt;, telecommunications and &lt;span class="caps"&gt;DSP&lt;/span&gt; to work in a practical setting and keep me from getting&amp;nbsp;rusty;&lt;/li&gt;
&lt;li&gt;To fill in the blanks in my knowledge of &lt;span class="caps"&gt;GNSS&lt;/span&gt; receivers&amp;#8217; inner&amp;nbsp;workings;&lt;/li&gt;
&lt;li&gt;To learn about new software libraries and tools, in particular those concerning real time digital signal&amp;nbsp;processing;&lt;/li&gt;
&lt;li&gt;To improve my communication and documentation&amp;nbsp;skills.&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;&lt;/h1&gt;
&lt;h1&gt;Materials&lt;/h1&gt;
&lt;p&gt;There are only two components (three if you&amp;#8217;re counting a decent computer/laptop) required for this project. One is an active &lt;span class="caps"&gt;GPS&lt;/span&gt; Antenna in order to be able to receive &lt;span class="caps"&gt;GPS&lt;/span&gt; signals in the L1 band (1575.42 MHz center frequency) and the other is a Software Defined Radio (&lt;span class="caps"&gt;SDR&lt;/span&gt;) which is responsible for delivering to your computer the digital samples of these signals shifted to&amp;nbsp;baseband.&lt;/p&gt;
&lt;p&gt;I will go into further detail into the hardware in my next blog post so don&amp;#8217;t worry if you don&amp;#8217;t understand what this is for just yet. This section is only meant to give you an idea of what you&amp;#8217;ll need and the costs associated. The particular choices I made&amp;nbsp;are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.amazon.com/RTL-SDR-Blog-RTL2832U-Software-Telescopic/dp/B011HVUEME/ref=lp_10230687011_1_1?srs=10230687011&amp;amp;ie=UTF8&amp;amp;qid=1482078660&amp;amp;sr=8-1"&gt;&lt;span class="caps"&gt;RTL&lt;/span&gt;-&lt;span class="caps"&gt;SDR&lt;/span&gt; Blog &lt;span class="caps"&gt;USB&lt;/span&gt; Dongle&lt;/a&gt; (â¬26) I chose this over other generic &lt;span class="caps"&gt;USB&lt;/span&gt; &lt;span class="caps"&gt;DVB&lt;/span&gt;-T &lt;span class="caps"&gt;TV&lt;/span&gt; dongles because it has a software enabled bias-T which allows me to power an active antenna without additional hardware or soldering mods. It also has other nice enhancements over regular dongles for use in Software Defined Radio and an &lt;span class="caps"&gt;SMA&lt;/span&gt; antenna connector instead of the more common &lt;span class="caps"&gt;MCX&lt;/span&gt; which is great since we won&amp;#8217;t need additional parts to plug in our &lt;span class="caps"&gt;GPS&lt;/span&gt; antenna. You could also get the version without the two telescopic antennas which comes out cheaper (â¬20) since we&amp;#8217;re mostly interested in using a &lt;span class="caps"&gt;GPS&lt;/span&gt;&amp;nbsp;antenna.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.amazon.com/Waterproof-Active-Antenna-28dB-Gain/dp/B00LXRQY9A/ref=lp_10008493011_1_1?srs=10008493011&amp;amp;ie=UTF8&amp;amp;qid=1482079461&amp;amp;sr=8-1"&gt;&lt;span class="caps"&gt;GPS&lt;/span&gt; Active Antenna&lt;/a&gt; (â¬15) Any active &lt;span class="caps"&gt;GPS&lt;/span&gt; antenna should do, there are plenty available at Amazon and other specialized&amp;nbsp;sellers.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Below is a picture I took of the &lt;span class="caps"&gt;USB&lt;/span&gt; dongle and the &lt;span class="caps"&gt;GPS&lt;/span&gt; antenna with a 2 Euro coin for&amp;nbsp;scale:&lt;/p&gt;
&lt;p&gt;&lt;img alt="RTL Dongle and GPS Antenna" src="https://ajoo.blog/images/RTL_dongle_and_GPS_antenna.jpg"&gt;&lt;/p&gt;
&lt;h1&gt;Software&lt;/h1&gt;
&lt;p&gt;Software based &lt;span class="caps"&gt;GNSS&lt;/span&gt; receivers are hardly uncharted waters. There are full fledged software libraries meant to accomplish what this little project of mine set out to do. Below is a list of those I&amp;#8217;m aware&amp;nbsp;of:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/taroz/GNSS-SDRLIB"&gt;gnss-sdrlib&lt;/a&gt; An open source &lt;span class="caps"&gt;GNSS&lt;/span&gt; Software Defined Radio Library with nice &lt;span class="caps"&gt;GUI&lt;/span&gt; elements written in C and&amp;nbsp;C++&lt;/li&gt;
&lt;li&gt;&lt;a href="http://gnss-sdr.org"&gt;gnss-sdr&lt;/a&gt; An open source library for implementing &lt;span class="caps"&gt;GNSS&lt;/span&gt; software defined receivers in C++. Based on &lt;span class="caps"&gt;GNU&lt;/span&gt;&amp;nbsp;Radio.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.rtklib.com/"&gt;rtklib&lt;/a&gt; An open source program package for &lt;span class="caps"&gt;GNSS&lt;/span&gt;&amp;nbsp;positioning&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I will not rely on these libraries except maybe for inspiration and test purposes as this project is meant mostly as an educational experience for myself and for any readers out there. I will attempt to make my posts as informative and as self-contained as possible so that I can refer back to them in the future and so that any reader might follow along and understand how to decode &lt;span class="caps"&gt;GNSS&lt;/span&gt; signals without having to refer to external materials. I will assume only basic knowledge of telecommunications, specially regarding the use of Fourier transforms and time &amp;lt;-&amp;gt; frequency representation of signals but no previous knowledge of &lt;span class="caps"&gt;GNSS&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;That being said, here are the major pieces of software that I do plan on&amp;nbsp;using:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.continuum.io/downloads"&gt;Python&lt;/a&gt; It&amp;#8217;s my language of choice for anything data science and scientific computing these days. It&amp;#8217;s open source unlike &lt;span class="caps"&gt;MATLAB&lt;/span&gt;, which is the other big workhorse in my scientific computing toolbox, and that makes it much more appropriate for this series. My choice of distribution is Anaconda which I&amp;#8217;ve been using for a long time and can personaly vouch for. It comes packed with all the scientific libraries you&amp;#8217;ll likely need for this little&amp;nbsp;project;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://gnuradio.org/"&gt;&lt;span class="caps"&gt;GNU&lt;/span&gt; Radio&lt;/a&gt; An open-source toolkit for &lt;span class="caps"&gt;SDR&lt;/span&gt;. Essentially a real-time capable &lt;span class="caps"&gt;DSP&lt;/span&gt; library that can be used in python and C++. I&amp;#8217;m planing to use this in order to be able to decode &lt;span class="caps"&gt;GPS&lt;/span&gt; signals in real time while I&amp;#8217;ll probably stick with the numpy and scipy python libraries for offline processing of collected data. The fact that there is an open source &lt;span class="caps"&gt;SDR&lt;/span&gt; &lt;span class="caps"&gt;GNSS&lt;/span&gt; library that&amp;#8217;s built on top of it leaves me hopeful that it is adequate for my&amp;nbsp;purposes.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Keep in mind that these is only what I &lt;em&gt;intend&lt;/em&gt; to use before diving in head first into this project. If at any point they feel inadequate I&amp;#8217;ll have reconsider my choices in order to push the project forward towards my end goals. For one, I&amp;#8217;ll probably have to delve into some C++ coding further on in order to implement functionality non existant in &lt;span class="caps"&gt;GNU&lt;/span&gt; Radio&amp;#8217;s base&amp;nbsp;distribution.&lt;/p&gt;
&lt;h1&gt;Related&amp;nbsp;Endeavours&lt;/h1&gt;
&lt;p&gt;While researching this topic I found a &lt;a href="http://sdrgps.blogspot.com"&gt;blog by Philip Hahn&lt;/a&gt; detailing his experiments with software defined radio &lt;span class="caps"&gt;GPS&lt;/span&gt; and its use in high-power rockets. It should be an interesting read for anyone interested in this&amp;nbsp;topic.&lt;/p&gt;
&lt;p&gt;Another very interesting &lt;a href="http://lea.hamradio.si/~s53mv/navsats/theory.html"&gt;website&lt;/a&gt; I came across on HackerNews documents the construction of a more conventional homemade &lt;span class="caps"&gt;GPS&lt;/span&gt;/&lt;span class="caps"&gt;GLONASS&lt;/span&gt; receiver by Matjaz Vidmar. It pretty much embodies what I hope to achieve with this series except with a lot less fiddling with physical hardware. While searching for the previous link after &amp;#8220;misplacing&amp;#8221; the bookmark I also stumbled upon a similar &lt;a href="http://www.aholme.co.uk/GPS/Main.htm"&gt;project by Andrew Holme&lt;/a&gt; that uses an &lt;span class="caps"&gt;FPGA&lt;/span&gt; to do a lot of &lt;span class="caps"&gt;DSP&lt;/span&gt; heavy&amp;nbsp;lifting.&lt;/p&gt;
&lt;h1&gt;Up&amp;nbsp;Next&lt;/h1&gt;
&lt;p&gt;My next post in this series will go into detail into what exactly is Software Defined Radio and the particular hardware and software that will be used in this project. Stay&amp;nbsp;tuned!&lt;/p&gt;</content><category term="GNSS"></category><category term="RTL-SDR"></category><category term="DSP"></category><category term="Python"></category></entry></feed>